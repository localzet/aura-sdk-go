// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActivateAllInboundsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivateAllInboundsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfActivateAllInboundsResponseDto = [1]string{
	0: "response",
}

// Decode decodes ActivateAllInboundsResponseDto from json.
func (s *ActivateAllInboundsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllInboundsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateAllInboundsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivateAllInboundsResponseDto) {
					name = jsonFieldsNameOfActivateAllInboundsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateAllInboundsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllInboundsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivateAllInboundsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfActivateAllInboundsResponseDtoResponse = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes ActivateAllInboundsResponseDtoResponse from json.
func (s *ActivateAllInboundsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllInboundsResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateAllInboundsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivateAllInboundsResponseDtoResponse) {
					name = jsonFieldsNameOfActivateAllInboundsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllInboundsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfActivateAllInboundsResponseDtoResponseActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem from json.
func (s *ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivateAllInboundsResponseDtoResponseActiveUserInboundsItem) {
					name = jsonFieldsNameOfActivateAllInboundsResponseDtoResponseActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllInboundsResponseDtoResponseActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivateAllInboundsResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfActivateAllInboundsResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes ActivateAllInboundsResponseDtoResponseHapp from json.
func (s *ActivateAllInboundsResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllInboundsResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateAllInboundsResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivateAllInboundsResponseDtoResponseHapp) {
					name = jsonFieldsNameOfActivateAllInboundsResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllInboundsResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivateAllInboundsResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfActivateAllInboundsResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes ActivateAllInboundsResponseDtoResponseLastConnectedNode from json.
func (s *ActivateAllInboundsResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllInboundsResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivateAllInboundsResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivateAllInboundsResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfActivateAllInboundsResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivateAllInboundsResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllInboundsResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateAllInboundsResponseDtoResponseStatus as json.
func (s ActivateAllInboundsResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActivateAllInboundsResponseDtoResponseStatus from json.
func (s *ActivateAllInboundsResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllInboundsResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActivateAllInboundsResponseDtoResponseStatus(v) {
	case ActivateAllInboundsResponseDtoResponseStatusACTIVE:
		*s = ActivateAllInboundsResponseDtoResponseStatusACTIVE
	case ActivateAllInboundsResponseDtoResponseStatusDISABLED:
		*s = ActivateAllInboundsResponseDtoResponseStatusDISABLED
	case ActivateAllInboundsResponseDtoResponseStatusLIMITED:
		*s = ActivateAllInboundsResponseDtoResponseStatusLIMITED
	case ActivateAllInboundsResponseDtoResponseStatusEXPIRED:
		*s = ActivateAllInboundsResponseDtoResponseStatusEXPIRED
	default:
		*s = ActivateAllInboundsResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActivateAllInboundsResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllInboundsResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy as json.
func (s ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy from json.
func (s *ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy(v) {
	case ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyNORESET
	case ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyDAY:
		*s = ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyDAY
	case ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyWEEK
	case ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = ActivateAllInboundsResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddInboundToNodesRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddInboundToNodesRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
}

var jsonFieldsNameOfAddInboundToNodesRequestDto = [1]string{
	0: "inboundUuid",
}

// Decode decodes AddInboundToNodesRequestDto from json.
func (s *AddInboundToNodesRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddInboundToNodesRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddInboundToNodesRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddInboundToNodesRequestDto) {
					name = jsonFieldsNameOfAddInboundToNodesRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddInboundToNodesRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddInboundToNodesRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddInboundToNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddInboundToNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfAddInboundToNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes AddInboundToNodesResponseDto from json.
func (s *AddInboundToNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddInboundToNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddInboundToNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddInboundToNodesResponseDto) {
					name = jsonFieldsNameOfAddInboundToNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddInboundToNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddInboundToNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddInboundToNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddInboundToNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isSuccess")
		e.Bool(s.IsSuccess)
	}
}

var jsonFieldsNameOfAddInboundToNodesResponseDtoResponse = [1]string{
	0: "isSuccess",
}

// Decode decodes AddInboundToNodesResponseDtoResponse from json.
func (s *AddInboundToNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddInboundToNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isSuccess":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsSuccess = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSuccess\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddInboundToNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddInboundToNodesResponseDtoResponse) {
					name = jsonFieldsNameOfAddInboundToNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddInboundToNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddInboundToNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddInboundToUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddInboundToUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
}

var jsonFieldsNameOfAddInboundToUsersRequestDto = [1]string{
	0: "inboundUuid",
}

// Decode decodes AddInboundToUsersRequestDto from json.
func (s *AddInboundToUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddInboundToUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddInboundToUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddInboundToUsersRequestDto) {
					name = jsonFieldsNameOfAddInboundToUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddInboundToUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddInboundToUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddInboundToUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddInboundToUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfAddInboundToUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes AddInboundToUsersResponseDto from json.
func (s *AddInboundToUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddInboundToUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddInboundToUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddInboundToUsersResponseDto) {
					name = jsonFieldsNameOfAddInboundToUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddInboundToUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddInboundToUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddInboundToUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddInboundToUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isSuccess")
		e.Bool(s.IsSuccess)
	}
}

var jsonFieldsNameOfAddInboundToUsersResponseDtoResponse = [1]string{
	0: "isSuccess",
}

// Decode decodes AddInboundToUsersResponseDtoResponse from json.
func (s *AddInboundToUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddInboundToUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isSuccess":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsSuccess = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSuccess\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddInboundToUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddInboundToUsersResponseDtoResponse) {
					name = jsonFieldsNameOfAddInboundToUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddInboundToUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddInboundToUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerLoginUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerLoginUnauthorized) encodeFields(e *jx.Encoder) {
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerLoginUnauthorized = [3]string{
	0: "statusCode",
	1: "message",
	2: "error",
}

// Decode decodes AuthControllerLoginUnauthorized from json.
func (s *AuthControllerLoginUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerLoginUnauthorized to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerLoginUnauthorized")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerLoginUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerLoginUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerRegisterForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerRegisterForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerRegisterForbidden = [3]string{
	0: "statusCode",
	1: "message",
	2: "error",
}

// Decode decodes AuthControllerRegisterForbidden from json.
func (s *AuthControllerRegisterForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerRegisterForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerRegisterForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerRegisterForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerRegisterForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllResetTrafficUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkAllResetTrafficUsersResponseDto from json.
func (s *BulkAllResetTrafficUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllResetTrafficUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllResetTrafficUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto) {
					name = jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllResetTrafficUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes BulkAllResetTrafficUsersResponseDtoResponse from json.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllResetTrafficUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllResetTrafficUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersRequestDto = [8]string{
	0: "status",
	1: "trafficLimitBytes",
	2: "trafficLimitStrategy",
	3: "expireAt",
	4: "description",
	5: "telegramId",
	6: "email",
	7: "tag",
}

// Decode decodes BulkAllUpdateUsersRequestDto from json.
func (s *BulkAllUpdateUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoStatus as json.
func (s BulkAllUpdateUsersRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkAllUpdateUsersRequestDtoStatus from json.
func (s *BulkAllUpdateUsersRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkAllUpdateUsersRequestDtoStatus(v) {
	case BulkAllUpdateUsersRequestDtoStatusACTIVE:
		*s = BulkAllUpdateUsersRequestDtoStatusACTIVE
	case BulkAllUpdateUsersRequestDtoStatusDISABLED:
		*s = BulkAllUpdateUsersRequestDtoStatusDISABLED
	case BulkAllUpdateUsersRequestDtoStatusLIMITED:
		*s = BulkAllUpdateUsersRequestDtoStatusLIMITED
	case BulkAllUpdateUsersRequestDtoStatusEXPIRED:
		*s = BulkAllUpdateUsersRequestDtoStatusEXPIRED
	default:
		*s = BulkAllUpdateUsersRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkAllUpdateUsersRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy as json.
func (s BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy from json.
func (s *BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkAllUpdateUsersRequestDtoTrafficLimitStrategy(v) {
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyNORESET:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyNORESET
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyDAY:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyDAY
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyWEEK:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyWEEK
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyMONTH:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkAllUpdateUsersResponseDto from json.
func (s *BulkAllUpdateUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllUpdateUsersResponseDto) {
					name = jsonFieldsNameOfBulkAllUpdateUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes BulkAllUpdateUsersResponseDtoResponse from json.
func (s *BulkAllUpdateUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDeleteHostsRequestDto from json.
func (s *BulkDeleteHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsRequestDto) {
					name = jsonFieldsNameOfBulkDeleteHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteHostsResponseDto from json.
func (s *BulkDeleteHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkDeleteHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkDeleteHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDto) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItem from json.
func (s *BulkDeleteHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkDeleteHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkDeleteHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDeleteHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDeleteHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusRequestDto = [1]string{
	0: "status",
}

// Decode decodes BulkDeleteUsersByStatusRequestDto from json.
func (s *BulkDeleteUsersByStatusRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusRequestDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteUsersByStatusRequestDtoStatus as json.
func (s BulkDeleteUsersByStatusRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDeleteUsersByStatusRequestDtoStatus from json.
func (s *BulkDeleteUsersByStatusRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDeleteUsersByStatusRequestDtoStatus(v) {
	case BulkDeleteUsersByStatusRequestDtoStatusACTIVE:
		*s = BulkDeleteUsersByStatusRequestDtoStatusACTIVE
	case BulkDeleteUsersByStatusRequestDtoStatusDISABLED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusDISABLED
	case BulkDeleteUsersByStatusRequestDtoStatusLIMITED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusLIMITED
	case BulkDeleteUsersByStatusRequestDtoStatusEXPIRED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusEXPIRED
	default:
		*s = BulkDeleteUsersByStatusRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDeleteUsersByStatusRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteUsersByStatusResponseDto from json.
func (s *BulkDeleteUsersByStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto) {
					name = jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkDeleteUsersByStatusResponseDtoResponse from json.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse) {
					name = jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteUsersRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDeleteUsersRequestDto from json.
func (s *BulkDeleteUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersRequestDto) {
					name = jsonFieldsNameOfBulkDeleteUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteUsersResponseDto from json.
func (s *BulkDeleteUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersResponseDto) {
					name = jsonFieldsNameOfBulkDeleteUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkDeleteUsersResponseDtoResponse from json.
func (s *BulkDeleteUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDisableHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDisableHostsRequestDto from json.
func (s *BulkDisableHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsRequestDto) {
					name = jsonFieldsNameOfBulkDisableHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDisableHostsResponseDto from json.
func (s *BulkDisableHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkDisableHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkDisableHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDto) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes BulkDisableHostsResponseDtoResponseItem from json.
func (s *BulkDisableHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDisableHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkDisableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkDisableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDisableHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDisableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkEnableHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkEnableHostsRequestDto from json.
func (s *BulkEnableHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsRequestDto) {
					name = jsonFieldsNameOfBulkEnableHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkEnableHostsResponseDto from json.
func (s *BulkEnableHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkEnableHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkEnableHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDto) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes BulkEnableHostsResponseDtoResponseItem from json.
func (s *BulkEnableHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkEnableHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkEnableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkEnableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkEnableHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkEnableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkResetTrafficUsersRequestDto from json.
func (s *BulkResetTrafficUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersRequestDto) {
					name = jsonFieldsNameOfBulkResetTrafficUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkResetTrafficUsersResponseDto from json.
func (s *BulkResetTrafficUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersResponseDto) {
					name = jsonFieldsNameOfBulkResetTrafficUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkResetTrafficUsersResponseDtoResponse from json.
func (s *BulkResetTrafficUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkRevokeUsersSubscriptionRequestDto from json.
func (s *BulkRevokeUsersSubscriptionRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkRevokeUsersSubscriptionResponseDto from json.
func (s *BulkRevokeUsersSubscriptionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkRevokeUsersSubscriptionResponseDtoResponse from json.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersInboundsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersInboundsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkUpdateUsersInboundsRequestDto = [2]string{
	0: "uuids",
	1: "activeUserInbounds",
}

// Decode decodes BulkUpdateUsersInboundsRequestDto from json.
func (s *BulkUpdateUsersInboundsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersInboundsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "activeUserInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersInboundsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersInboundsRequestDto) {
					name = jsonFieldsNameOfBulkUpdateUsersInboundsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersInboundsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersInboundsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersInboundsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersInboundsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersInboundsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkUpdateUsersInboundsResponseDto from json.
func (s *BulkUpdateUsersInboundsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersInboundsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersInboundsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersInboundsResponseDto) {
					name = jsonFieldsNameOfBulkUpdateUsersInboundsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersInboundsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersInboundsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersInboundsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersInboundsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkUpdateUsersInboundsResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkUpdateUsersInboundsResponseDtoResponse from json.
func (s *BulkUpdateUsersInboundsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersInboundsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersInboundsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersInboundsResponseDtoResponse) {
					name = jsonFieldsNameOfBulkUpdateUsersInboundsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersInboundsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersInboundsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("fields")
		s.Fields.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersRequestDto = [2]string{
	0: "uuids",
	1: "fields",
}

// Decode decodes BulkUpdateUsersRequestDto from json.
func (s *BulkUpdateUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "fields":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Fields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersRequestDto) {
					name = jsonFieldsNameOfBulkUpdateUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersRequestDtoFields) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersRequestDtoFields) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkUpdateUsersRequestDtoFields = [8]string{
	0: "status",
	1: "trafficLimitBytes",
	2: "trafficLimitStrategy",
	3: "expireAt",
	4: "description",
	5: "telegramId",
	6: "email",
	7: "tag",
}

// Decode decodes BulkUpdateUsersRequestDtoFields from json.
func (s *BulkUpdateUsersRequestDtoFields) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFields to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersRequestDtoFields")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersRequestDtoFields) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFields) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsStatus as json.
func (s BulkUpdateUsersRequestDtoFieldsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsStatus from json.
func (s *BulkUpdateUsersRequestDtoFieldsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFieldsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkUpdateUsersRequestDtoFieldsStatus(v) {
	case BulkUpdateUsersRequestDtoFieldsStatusACTIVE:
		*s = BulkUpdateUsersRequestDtoFieldsStatusACTIVE
	case BulkUpdateUsersRequestDtoFieldsStatusDISABLED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusDISABLED
	case BulkUpdateUsersRequestDtoFieldsStatusLIMITED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusLIMITED
	case BulkUpdateUsersRequestDtoFieldsStatusEXPIRED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusEXPIRED
	default:
		*s = BulkUpdateUsersRequestDtoFieldsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkUpdateUsersRequestDtoFieldsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFieldsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy as json.
func (s BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy from json.
func (s *BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy(v) {
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyNORESET:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyNORESET
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyDAY:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyDAY
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyWEEK:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyWEEK
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyMONTH:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyMONTH
	default:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkUpdateUsersResponseDto from json.
func (s *BulkUpdateUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersResponseDto) {
					name = jsonFieldsNameOfBulkUpdateUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkUpdateUsersResponseDtoResponse from json.
func (s *BulkUpdateUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tokenName")
		e.Str(s.TokenName)
	}
	{
		e.FieldStart("tokenDescription")
		s.TokenDescription.Encode(e)
	}
}

var jsonFieldsNameOfCreateApiTokenRequestDto = [2]string{
	0: "tokenName",
	1: "tokenDescription",
}

// Decode decodes CreateApiTokenRequestDto from json.
func (s *CreateApiTokenRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tokenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TokenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenName\"")
			}
		case "tokenDescription":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TokenDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenRequestDto) {
					name = jsonFieldsNameOfCreateApiTokenRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateApiTokenResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateApiTokenResponseDto from json.
func (s *CreateApiTokenResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenResponseDto) {
					name = jsonFieldsNameOfCreateApiTokenResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
}

var jsonFieldsNameOfCreateApiTokenResponseDtoResponse = [2]string{
	0: "token",
	1: "uuid",
}

// Decode decodes CreateApiTokenResponseDtoResponse from json.
func (s *CreateApiTokenResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenResponseDtoResponse) {
					name = jsonFieldsNameOfCreateApiTokenResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfCreateHostRequestDto = [13]string{
	0:  "inboundUuid",
	1:  "remark",
	2:  "address",
	3:  "port",
	4:  "path",
	5:  "sni",
	6:  "host",
	7:  "alpn",
	8:  "fingerprint",
	9:  "allowInsecure",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
}

// Decode decodes CreateHostRequestDto from json.
func (s *CreateHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostRequestDto) {
					name = jsonFieldsNameOfCreateHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoAlpn as json.
func (s CreateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoAlpn from json.
func (s *CreateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoAlpn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoAlpn(v) {
	case CreateHostRequestDtoAlpnH3:
		*s = CreateHostRequestDtoAlpnH3
	case CreateHostRequestDtoAlpnH2:
		*s = CreateHostRequestDtoAlpnH2
	case CreateHostRequestDtoAlpnHTTP11:
		*s = CreateHostRequestDtoAlpnHTTP11
	case CreateHostRequestDtoAlpnH2HTTP11:
		*s = CreateHostRequestDtoAlpnH2HTTP11
	case CreateHostRequestDtoAlpnH3H2HTTP11:
		*s = CreateHostRequestDtoAlpnH3H2HTTP11
	case CreateHostRequestDtoAlpnH3H2:
		*s = CreateHostRequestDtoAlpnH3H2
	default:
		*s = CreateHostRequestDtoAlpn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoFingerprint as json.
func (s CreateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoFingerprint from json.
func (s *CreateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoFingerprint to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoFingerprint(v) {
	case CreateHostRequestDtoFingerprintChrome:
		*s = CreateHostRequestDtoFingerprintChrome
	case CreateHostRequestDtoFingerprintFirefox:
		*s = CreateHostRequestDtoFingerprintFirefox
	case CreateHostRequestDtoFingerprintSafari:
		*s = CreateHostRequestDtoFingerprintSafari
	case CreateHostRequestDtoFingerprintIos:
		*s = CreateHostRequestDtoFingerprintIos
	case CreateHostRequestDtoFingerprintAndroid:
		*s = CreateHostRequestDtoFingerprintAndroid
	case CreateHostRequestDtoFingerprintEdge:
		*s = CreateHostRequestDtoFingerprintEdge
	case CreateHostRequestDtoFingerprintQq:
		*s = CreateHostRequestDtoFingerprintQq
	case CreateHostRequestDtoFingerprintRandom:
		*s = CreateHostRequestDtoFingerprintRandom
	case CreateHostRequestDtoFingerprintRandomized:
		*s = CreateHostRequestDtoFingerprintRandomized
	default:
		*s = CreateHostRequestDtoFingerprint(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoSecurityLayer as json.
func (s CreateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoSecurityLayer from json.
func (s *CreateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoSecurityLayer(v) {
	case CreateHostRequestDtoSecurityLayerDEFAULT:
		*s = CreateHostRequestDtoSecurityLayerDEFAULT
	case CreateHostRequestDtoSecurityLayerTLS:
		*s = CreateHostRequestDtoSecurityLayerTLS
	case CreateHostRequestDtoSecurityLayerNONE:
		*s = CreateHostRequestDtoSecurityLayerNONE
	default:
		*s = CreateHostRequestDtoSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateHostResponseDto from json.
func (s *CreateHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDto) {
					name = jsonFieldsNameOfCreateHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfCreateHostResponseDtoResponse = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes CreateHostResponseDtoResponse from json.
func (s *CreateHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDtoResponse) {
					name = jsonFieldsNameOfCreateHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostResponseDtoResponseSecurityLayer as json.
func (s CreateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostResponseDtoResponseSecurityLayer from json.
func (s *CreateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostResponseDtoResponseSecurityLayer(v) {
	case CreateHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = CreateHostResponseDtoResponseSecurityLayerDEFAULT
	case CreateHostResponseDtoResponseSecurityLayerTLS:
		*s = CreateHostResponseDtoResponseSecurityLayerTLS
	case CreateHostResponseDtoResponseSecurityLayerNONE:
		*s = CreateHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = CreateHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.IsTrafficTrackingActive.Set {
			e.FieldStart("isTrafficTrackingActive")
			s.IsTrafficTrackingActive.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.NotifyPercent.Set {
			e.FieldStart("notifyPercent")
			s.NotifyPercent.Encode(e)
		}
	}
	{
		if s.TrafficResetDay.Set {
			e.FieldStart("trafficResetDay")
			s.TrafficResetDay.Encode(e)
		}
	}
	{
		if s.ExcludedInbounds != nil {
			e.FieldStart("excludedInbounds")
			e.ArrStart()
			for _, elem := range s.ExcludedInbounds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CountryCode.Set {
			e.FieldStart("countryCode")
			s.CountryCode.Encode(e)
		}
	}
	{
		if s.ConsumptionMultiplier.Set {
			e.FieldStart("consumptionMultiplier")
			s.ConsumptionMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateNodeRequestDto = [10]string{
	0: "name",
	1: "address",
	2: "port",
	3: "isTrafficTrackingActive",
	4: "trafficLimitBytes",
	5: "notifyPercent",
	6: "trafficResetDay",
	7: "excludedInbounds",
	8: "countryCode",
	9: "consumptionMultiplier",
}

// Decode decodes CreateNodeRequestDto from json.
func (s *CreateNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeRequestDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isTrafficTrackingActive":
			if err := func() error {
				s.IsTrafficTrackingActive.Reset()
				if err := s.IsTrafficTrackingActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "notifyPercent":
			if err := func() error {
				s.NotifyPercent.Reset()
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "trafficResetDay":
			if err := func() error {
				s.TrafficResetDay.Reset()
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "excludedInbounds":
			if err := func() error {
				s.ExcludedInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		case "countryCode":
			if err := func() error {
				s.CountryCode.Reset()
				if err := s.CountryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			if err := func() error {
				s.ConsumptionMultiplier.Reset()
				if err := s.ConsumptionMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeRequestDto) {
					name = jsonFieldsNameOfCreateNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateNodeResponseDto from json.
func (s *CreateNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDto) {
					name = jsonFieldsNameOfCreateNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("excludedInbounds")
		e.ArrStart()
		for _, elem := range s.ExcludedInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponse = [28]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "xrayUptime",
	13: "isTrafficTrackingActive",
	14: "trafficResetDay",
	15: "trafficLimitBytes",
	16: "trafficUsedBytes",
	17: "notifyPercent",
	18: "usersOnline",
	19: "viewPosition",
	20: "countryCode",
	21: "consumptionMultiplier",
	22: "cpuCount",
	23: "cpuModel",
	24: "totalRam",
	25: "createdAt",
	26: "updatedAt",
	27: "excludedInbounds",
}

// Decode decodes CreateNodeResponseDtoResponse from json.
func (s *CreateNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "excludedInbounds":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				s.ExcludedInbounds = make([]CreateNodeResponseDtoResponseExcludedInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateNodeResponseDtoResponseExcludedInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponse) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponseExcludedInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponseExcludedInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponseExcludedInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes CreateNodeResponseDtoResponseExcludedInboundsItem from json.
func (s *CreateNodeResponseDtoResponseExcludedInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponseExcludedInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponseExcludedInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponseExcludedInboundsItem) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponseExcludedInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponseExcludedInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponseExcludedInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		if s.Platform.Set {
			e.FieldStart("platform")
			s.Platform.Encode(e)
		}
	}
	{
		if s.OsVersion.Set {
			e.FieldStart("osVersion")
			s.OsVersion.Encode(e)
		}
	}
	{
		if s.DeviceModel.Set {
			e.FieldStart("deviceModel")
			s.DeviceModel.Encode(e)
		}
	}
	{
		if s.UserAgent.Set {
			e.FieldStart("userAgent")
			s.UserAgent.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceRequestDto = [6]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
}

// Decode decodes CreateUserHwidDeviceRequestDto from json.
func (s *CreateUserHwidDeviceRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			if err := func() error {
				s.Platform.Reset()
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			if err := func() error {
				s.OsVersion.Reset()
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			if err := func() error {
				s.DeviceModel.Reset()
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			if err := func() error {
				s.UserAgent.Reset()
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceRequestDto) {
					name = jsonFieldsNameOfCreateUserHwidDeviceRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateUserHwidDeviceResponseDto from json.
func (s *CreateUserHwidDeviceResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]CreateUserHwidDeviceResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateUserHwidDeviceResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDto) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes CreateUserHwidDeviceResponseDtoResponseItem from json.
func (s *CreateUserHwidDeviceResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseItem) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.SubscriptionUuid.Set {
			e.FieldStart("subscriptionUuid")
			s.SubscriptionUuid.Encode(e)
		}
	}
	{
		if s.ShortUuid.Set {
			e.FieldStart("shortUuid")
			s.ShortUuid.Encode(e)
		}
	}
	{
		if s.TrojanPassword.Set {
			e.FieldStart("trojanPassword")
			s.TrojanPassword.Encode(e)
		}
	}
	{
		if s.VlessUuid.Set {
			e.FieldStart("vlessUuid")
			s.VlessUuid.Encode(e)
		}
	}
	{
		if s.SsPassword.Set {
			e.FieldStart("ssPassword")
			s.SsPassword.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
	{
		if s.ActiveUserInbounds != nil {
			e.FieldStart("activeUserInbounds")
			e.ArrStart()
			for _, elem := range s.ActiveUserInbounds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastTrafficResetAt.Set {
			e.FieldStart("lastTrafficResetAt")
			s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
	{
		if s.ActivateAllInbounds.Set {
			e.FieldStart("activateAllInbounds")
			s.ActivateAllInbounds.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserRequestDto = [19]string{
	0:  "username",
	1:  "status",
	2:  "subscriptionUuid",
	3:  "shortUuid",
	4:  "trojanPassword",
	5:  "vlessUuid",
	6:  "ssPassword",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "activeUserInbounds",
	10: "expireAt",
	11: "createdAt",
	12: "lastTrafficResetAt",
	13: "description",
	14: "tag",
	15: "telegramId",
	16: "email",
	17: "hwidDeviceLimit",
	18: "activateAllInbounds",
}

// Decode decodes CreateUserRequestDto from json.
func (s *CreateUserRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDto to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subscriptionUuid":
			if err := func() error {
				s.SubscriptionUuid.Reset()
				if err := s.SubscriptionUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			if err := func() error {
				s.ShortUuid.Reset()
				if err := s.ShortUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "trojanPassword":
			if err := func() error {
				s.TrojanPassword.Reset()
				if err := s.TrojanPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			if err := func() error {
				s.VlessUuid.Reset()
				if err := s.VlessUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			if err := func() error {
				s.SsPassword.Reset()
				if err := s.SsPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "activeUserInbounds":
			if err := func() error {
				s.ActiveUserInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "lastTrafficResetAt":
			if err := func() error {
				s.LastTrafficResetAt.Reset()
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "activateAllInbounds":
			if err := func() error {
				s.ActivateAllInbounds.Reset()
				if err := s.ActivateAllInbounds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activateAllInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserRequestDto) {
					name = jsonFieldsNameOfCreateUserRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoStatus as json.
func (s CreateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserRequestDtoStatus from json.
func (s *CreateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserRequestDtoStatus(v) {
	case CreateUserRequestDtoStatusACTIVE:
		*s = CreateUserRequestDtoStatusACTIVE
	case CreateUserRequestDtoStatusDISABLED:
		*s = CreateUserRequestDtoStatusDISABLED
	case CreateUserRequestDtoStatusLIMITED:
		*s = CreateUserRequestDtoStatusLIMITED
	case CreateUserRequestDtoStatusEXPIRED:
		*s = CreateUserRequestDtoStatusEXPIRED
	default:
		*s = CreateUserRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoTrafficLimitStrategy as json.
func (s CreateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserRequestDtoTrafficLimitStrategy from json.
func (s *CreateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserRequestDtoTrafficLimitStrategy(v) {
	case CreateUserRequestDtoTrafficLimitStrategyNORESET:
		*s = CreateUserRequestDtoTrafficLimitStrategyNORESET
	case CreateUserRequestDtoTrafficLimitStrategyDAY:
		*s = CreateUserRequestDtoTrafficLimitStrategyDAY
	case CreateUserRequestDtoTrafficLimitStrategyWEEK:
		*s = CreateUserRequestDtoTrafficLimitStrategyWEEK
	case CreateUserRequestDtoTrafficLimitStrategyMONTH:
		*s = CreateUserRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = CreateUserRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteApiTokenResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteApiTokenResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.Bool(s.Response)
	}
}

var jsonFieldsNameOfDeleteApiTokenResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteApiTokenResponseDto from json.
func (s *DeleteApiTokenResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteApiTokenResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Response = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteApiTokenResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteApiTokenResponseDto) {
					name = jsonFieldsNameOfDeleteApiTokenResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteApiTokenResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteApiTokenResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteHostResponseDto from json.
func (s *DeleteHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteHostResponseDto) {
					name = jsonFieldsNameOfDeleteHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteHostResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteHostResponseDtoResponse from json.
func (s *DeleteHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteHostResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteHostResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteNodeResponseDto from json.
func (s *DeleteNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteNodeResponseDto) {
					name = jsonFieldsNameOfDeleteNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteNodeResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteNodeResponseDtoResponse from json.
func (s *DeleteNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteNodeResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceRequestDto = [2]string{
	0: "userUuid",
	1: "hwid",
}

// Decode decodes DeleteUserHwidDeviceRequestDto from json.
func (s *DeleteUserHwidDeviceRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "hwid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceRequestDto) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteUserHwidDeviceResponseDto from json.
func (s *DeleteUserHwidDeviceResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]DeleteUserHwidDeviceResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteUserHwidDeviceResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDto) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes DeleteUserHwidDeviceResponseDtoResponseItem from json.
func (s *DeleteUserHwidDeviceResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseItem) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteUserResponseDto from json.
func (s *DeleteUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserResponseDto) {
					name = jsonFieldsNameOfDeleteUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteUserResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteUserResponseDtoResponse from json.
func (s *DeleteUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDisableNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes DisableNodeResponseDto from json.
func (s *DisableNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDto) {
					name = jsonFieldsNameOfDisableNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("excludedInbounds")
		e.ArrStart()
		for _, elem := range s.ExcludedInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponse = [28]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "xrayUptime",
	13: "isTrafficTrackingActive",
	14: "trafficResetDay",
	15: "trafficLimitBytes",
	16: "trafficUsedBytes",
	17: "notifyPercent",
	18: "usersOnline",
	19: "viewPosition",
	20: "countryCode",
	21: "consumptionMultiplier",
	22: "cpuCount",
	23: "cpuModel",
	24: "totalRam",
	25: "createdAt",
	26: "updatedAt",
	27: "excludedInbounds",
}

// Decode decodes DisableNodeResponseDtoResponse from json.
func (s *DisableNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "excludedInbounds":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				s.ExcludedInbounds = make([]DisableNodeResponseDtoResponseExcludedInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DisableNodeResponseDtoResponseExcludedInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponse) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponseExcludedInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponseExcludedInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponseExcludedInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes DisableNodeResponseDtoResponseExcludedInboundsItem from json.
func (s *DisableNodeResponseDtoResponseExcludedInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponseExcludedInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponseExcludedInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponseExcludedInboundsItem) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponseExcludedInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponseExcludedInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponseExcludedInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDisableUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes DisableUserResponseDto from json.
func (s *DisableUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDto) {
					name = jsonFieldsNameOfDisableUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponse = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes DisableUserResponseDtoResponse from json.
func (s *DisableUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]DisableUserResponseDtoResponseActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DisableUserResponseDtoResponseActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponse) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes DisableUserResponseDtoResponseActiveUserInboundsItem from json.
func (s *DisableUserResponseDtoResponseActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseActiveUserInboundsItem) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes DisableUserResponseDtoResponseHapp from json.
func (s *DisableUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes DisableUserResponseDtoResponseLastConnectedNode from json.
func (s *DisableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseStatus as json.
func (s DisableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DisableUserResponseDtoResponseStatus from json.
func (s *DisableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DisableUserResponseDtoResponseStatus(v) {
	case DisableUserResponseDtoResponseStatusACTIVE:
		*s = DisableUserResponseDtoResponseStatusACTIVE
	case DisableUserResponseDtoResponseStatusDISABLED:
		*s = DisableUserResponseDtoResponseStatusDISABLED
	case DisableUserResponseDtoResponseStatusLIMITED:
		*s = DisableUserResponseDtoResponseStatusLIMITED
	case DisableUserResponseDtoResponseStatusEXPIRED:
		*s = DisableUserResponseDtoResponseStatusEXPIRED
	default:
		*s = DisableUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseTrafficLimitStrategy as json.
func (s DisableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DisableUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *DisableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DisableUserResponseDtoResponseTrafficLimitStrategy(v) {
	case DisableUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyNORESET
	case DisableUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyDAY
	case DisableUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyWEEK
	case DisableUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfEnableNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes EnableNodeResponseDto from json.
func (s *EnableNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDto) {
					name = jsonFieldsNameOfEnableNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("excludedInbounds")
		e.ArrStart()
		for _, elem := range s.ExcludedInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponse = [28]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "xrayUptime",
	13: "isTrafficTrackingActive",
	14: "trafficResetDay",
	15: "trafficLimitBytes",
	16: "trafficUsedBytes",
	17: "notifyPercent",
	18: "usersOnline",
	19: "viewPosition",
	20: "countryCode",
	21: "consumptionMultiplier",
	22: "cpuCount",
	23: "cpuModel",
	24: "totalRam",
	25: "createdAt",
	26: "updatedAt",
	27: "excludedInbounds",
}

// Decode decodes EnableNodeResponseDtoResponse from json.
func (s *EnableNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "excludedInbounds":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				s.ExcludedInbounds = make([]EnableNodeResponseDtoResponseExcludedInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnableNodeResponseDtoResponseExcludedInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponse) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponseExcludedInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponseExcludedInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponseExcludedInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes EnableNodeResponseDtoResponseExcludedInboundsItem from json.
func (s *EnableNodeResponseDtoResponseExcludedInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponseExcludedInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponseExcludedInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponseExcludedInboundsItem) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponseExcludedInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponseExcludedInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponseExcludedInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfEnableUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes EnableUserResponseDto from json.
func (s *EnableUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDto) {
					name = jsonFieldsNameOfEnableUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponse = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes EnableUserResponseDtoResponse from json.
func (s *EnableUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]EnableUserResponseDtoResponseActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnableUserResponseDtoResponseActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponse) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes EnableUserResponseDtoResponseActiveUserInboundsItem from json.
func (s *EnableUserResponseDtoResponseActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseActiveUserInboundsItem) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes EnableUserResponseDtoResponseHapp from json.
func (s *EnableUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes EnableUserResponseDtoResponseLastConnectedNode from json.
func (s *EnableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseStatus as json.
func (s EnableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnableUserResponseDtoResponseStatus from json.
func (s *EnableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnableUserResponseDtoResponseStatus(v) {
	case EnableUserResponseDtoResponseStatusACTIVE:
		*s = EnableUserResponseDtoResponseStatusACTIVE
	case EnableUserResponseDtoResponseStatusDISABLED:
		*s = EnableUserResponseDtoResponseStatusDISABLED
	case EnableUserResponseDtoResponseStatusLIMITED:
		*s = EnableUserResponseDtoResponseStatusLIMITED
	case EnableUserResponseDtoResponseStatusEXPIRED:
		*s = EnableUserResponseDtoResponseStatusEXPIRED
	default:
		*s = EnableUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseTrafficLimitStrategy as json.
func (s EnableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnableUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *EnableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnableUserResponseDtoResponseTrafficLimitStrategy(v) {
	case EnableUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyNORESET
	case EnableUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyDAY
	case EnableUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyWEEK
	case EnableUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDto = [1]string{
	0: "response",
}

// Decode decodes FindAllApiTokensResponseDto from json.
func (s *FindAllApiTokensResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDto) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiKeys")
		e.ArrStart()
		for _, elem := range s.ApiKeys {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("docs")
		s.Docs.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponse = [2]string{
	0: "apiKeys",
	1: "docs",
}

// Decode decodes FindAllApiTokensResponseDtoResponse from json.
func (s *FindAllApiTokensResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiKeys":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ApiKeys = make([]FindAllApiTokensResponseDtoResponseApiKeysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FindAllApiTokensResponseDtoResponseApiKeysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ApiKeys = append(s.ApiKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKeys\"")
			}
		case "docs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Docs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"docs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponse) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("tokenName")
		e.Str(s.TokenName)
	}
	{
		e.FieldStart("tokenDescription")
		s.TokenDescription.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem = [6]string{
	0: "uuid",
	1: "token",
	2: "tokenName",
	3: "tokenDescription",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes FindAllApiTokensResponseDtoResponseApiKeysItem from json.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponseApiKeysItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "tokenName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TokenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenName\"")
			}
		case "tokenDescription":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.TokenDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenDescription\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponseApiKeysItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponseDocs) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDocsEnabled")
		e.Bool(s.IsDocsEnabled)
	}
	{
		e.FieldStart("scalarPath")
		s.ScalarPath.Encode(e)
	}
	{
		e.FieldStart("swaggerPath")
		s.SwaggerPath.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs = [3]string{
	0: "isDocsEnabled",
	1: "scalarPath",
	2: "swaggerPath",
}

// Decode decodes FindAllApiTokensResponseDtoResponseDocs from json.
func (s *FindAllApiTokensResponseDtoResponseDocs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponseDocs to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDocsEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDocsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDocsEnabled\"")
			}
		case "scalarPath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ScalarPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scalarPath\"")
			}
		case "swaggerPath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SwaggerPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swaggerPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponseDocs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllHostsResponseDto from json.
func (s *GetAllHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetAllHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDto) {
					name = jsonFieldsNameOfGetAllHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfGetAllHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes GetAllHostsResponseDtoResponseItem from json.
func (s *GetAllHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetAllHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllHostsResponseDtoResponseItemSecurityLayer as json.
func (s GetAllHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllHostsResponseDtoResponseItemSecurityLayer from json.
func (s *GetAllHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllHostsResponseDtoResponseItemSecurityLayer(v) {
	case GetAllHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case GetAllHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerTLS
	case GetAllHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllNodesResponseDto from json.
func (s *GetAllNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetAllNodesResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllNodesResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDto) {
					name = jsonFieldsNameOfGetAllNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("excludedInbounds")
		e.ArrStart()
		for _, elem := range s.ExcludedInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItem = [28]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "xrayUptime",
	13: "isTrafficTrackingActive",
	14: "trafficResetDay",
	15: "trafficLimitBytes",
	16: "trafficUsedBytes",
	17: "notifyPercent",
	18: "usersOnline",
	19: "viewPosition",
	20: "countryCode",
	21: "consumptionMultiplier",
	22: "cpuCount",
	23: "cpuModel",
	24: "totalRam",
	25: "createdAt",
	26: "updatedAt",
	27: "excludedInbounds",
}

// Decode decodes GetAllNodesResponseDtoResponseItem from json.
func (s *GetAllNodesResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "excludedInbounds":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				s.ExcludedInbounds = make([]GetAllNodesResponseDtoResponseItemExcludedInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllNodesResponseDtoResponseItemExcludedInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemExcludedInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItemExcludedInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItemExcludedInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes GetAllNodesResponseDtoResponseItemExcludedInboundsItem from json.
func (s *GetAllNodesResponseDtoResponseItemExcludedInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItemExcludedInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItemExcludedInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItemExcludedInboundsItem) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItemExcludedInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemExcludedInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItemExcludedInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllSubscriptionsResponseDto from json.
func (s *GetAllSubscriptionsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDto) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subscriptions")
		e.ArrStart()
		for _, elem := range s.Subscriptions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse = [2]string{
	0: "subscriptions",
	1: "total",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponse from json.
func (s *GetAllSubscriptionsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscriptions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Subscriptions = make([]GetAllSubscriptionsResponseDtoResponseSubscriptionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllSubscriptionsResponseDtoResponseSubscriptionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subscriptions = append(s.Subscriptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem = [5]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItem from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy as json.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy(v) {
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyNORESET:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyNORESET
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyDAY:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyDAY
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyWEEK:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyWEEK
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyMONTH:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyMONTH
	default:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus as json.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus(v) {
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusACTIVE:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusACTIVE
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusDISABLED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusDISABLED
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusLIMITED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusLIMITED
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusEXPIRED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusEXPIRED
	default:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTagsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTagsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllTagsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllTagsResponseDto from json.
func (s *GetAllTagsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTagsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTagsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllTagsResponseDto) {
					name = jsonFieldsNameOfGetAllTagsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTagsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTagsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTagsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTagsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllTagsResponseDtoResponse = [1]string{
	0: "tags",
}

// Decode decodes GetAllTagsResponseDtoResponse from json.
func (s *GetAllTagsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTagsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTagsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllTagsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllTagsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTagsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTagsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllUsersResponseDto from json.
func (s *GetAllUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDto) {
					name = jsonFieldsNameOfGetAllUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDtoResponse = [2]string{
	0: "users",
	1: "total",
}

// Decode decodes GetAllUsersResponseDtoResponse from json.
func (s *GetAllUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]UserDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetBandwidthStatsResponseDto from json.
func (s *GetBandwidthStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDto) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bandwidthLastTwoDays")
		s.BandwidthLastTwoDays.Encode(e)
	}
	{
		e.FieldStart("bandwidthLastSevenDays")
		s.BandwidthLastSevenDays.Encode(e)
	}
	{
		e.FieldStart("bandwidthLast30Days")
		s.BandwidthLast30Days.Encode(e)
	}
	{
		e.FieldStart("bandwidthCalendarMonth")
		s.BandwidthCalendarMonth.Encode(e)
	}
	{
		e.FieldStart("bandwidthCurrentYear")
		s.BandwidthCurrentYear.Encode(e)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse = [5]string{
	0: "bandwidthLastTwoDays",
	1: "bandwidthLastSevenDays",
	2: "bandwidthLast30Days",
	3: "bandwidthCalendarMonth",
	4: "bandwidthCurrentYear",
}

// Decode decodes GetBandwidthStatsResponseDtoResponse from json.
func (s *GetBandwidthStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bandwidthLastTwoDays":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BandwidthLastTwoDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLastTwoDays\"")
			}
		case "bandwidthLastSevenDays":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BandwidthLastSevenDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLastSevenDays\"")
			}
		case "bandwidthLast30Days":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.BandwidthLast30Days.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLast30Days\"")
			}
		case "bandwidthCalendarMonth":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.BandwidthCalendarMonth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthCalendarMonth\"")
			}
		case "bandwidthCurrentYear":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.BandwidthCurrentYear.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthCurrentYear\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLast30Days from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLast30Days to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLast30Days")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetConfigResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetConfigResponseDto from json.
func (s *GetConfigResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigResponseDto) {
					name = jsonFieldsNameOfGetConfigResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
}

var jsonFieldsNameOfGetConfigResponseDtoResponse = [1]string{
	0: "config",
}

// Decode decodes GetConfigResponseDtoResponse from json.
func (s *GetConfigResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigResponseDtoResponse) {
					name = jsonFieldsNameOfGetConfigResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetFullInboundsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetFullInboundsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetFullInboundsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetFullInboundsResponseDto from json.
func (s *GetFullInboundsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFullInboundsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetFullInboundsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetFullInboundsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetFullInboundsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetFullInboundsResponseDto) {
					name = jsonFieldsNameOfGetFullInboundsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFullInboundsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFullInboundsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetFullInboundsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("port")
		e.Float64(s.Port)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("rawFromConfig")
		s.RawFromConfig.Encode(e)
	}
	{
		e.FieldStart("users")
		s.Users.Encode(e)
	}
	{
		e.FieldStart("nodes")
		s.Nodes.Encode(e)
	}
}

var jsonFieldsNameOfGetFullInboundsResponseDtoResponseItem = [9]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "port",
	4: "network",
	5: "security",
	6: "rawFromConfig",
	7: "users",
	8: "nodes",
}

// Decode decodes GetFullInboundsResponseDtoResponseItem from json.
func (s *GetFullInboundsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFullInboundsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Port = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "rawFromConfig":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.RawFromConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawFromConfig\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Users.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "nodes":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Nodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetFullInboundsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetFullInboundsResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetFullInboundsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFullInboundsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItemNodes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetFullInboundsResponseDtoResponseItemNodes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Float64(s.Enabled)
	}
	{
		e.FieldStart("disabled")
		e.Float64(s.Disabled)
	}
}

var jsonFieldsNameOfGetFullInboundsResponseDtoResponseItemNodes = [2]string{
	0: "enabled",
	1: "disabled",
}

// Decode decodes GetFullInboundsResponseDtoResponseItemNodes from json.
func (s *GetFullInboundsResponseDtoResponseItemNodes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFullInboundsResponseDtoResponseItemNodes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Enabled = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "disabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Disabled = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetFullInboundsResponseDtoResponseItemNodes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetFullInboundsResponseDtoResponseItemNodes) {
					name = jsonFieldsNameOfGetFullInboundsResponseDtoResponseItemNodes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItemNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFullInboundsResponseDtoResponseItemNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItemRawFromConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetFullInboundsResponseDtoResponseItemRawFromConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetFullInboundsResponseDtoResponseItemRawFromConfig = [0]string{}

// Decode decodes GetFullInboundsResponseDtoResponseItemRawFromConfig from json.
func (s *GetFullInboundsResponseDtoResponseItemRawFromConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFullInboundsResponseDtoResponseItemRawFromConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetFullInboundsResponseDtoResponseItemRawFromConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItemRawFromConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFullInboundsResponseDtoResponseItemRawFromConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItemUsers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetFullInboundsResponseDtoResponseItemUsers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Float64(s.Enabled)
	}
	{
		e.FieldStart("disabled")
		e.Float64(s.Disabled)
	}
}

var jsonFieldsNameOfGetFullInboundsResponseDtoResponseItemUsers = [2]string{
	0: "enabled",
	1: "disabled",
}

// Decode decodes GetFullInboundsResponseDtoResponseItemUsers from json.
func (s *GetFullInboundsResponseDtoResponseItemUsers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFullInboundsResponseDtoResponseItemUsers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Enabled = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "disabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Disabled = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetFullInboundsResponseDtoResponseItemUsers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetFullInboundsResponseDtoResponseItemUsers) {
					name = jsonFieldsNameOfGetFullInboundsResponseDtoResponseItemUsers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetFullInboundsResponseDtoResponseItemUsers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFullInboundsResponseDtoResponseItemUsers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInboundsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInboundsResponseDto from json.
func (s *GetInboundsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetInboundsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInboundsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsResponseDto) {
					name = jsonFieldsNameOfGetInboundsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("port")
		e.Float64(s.Port)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfGetInboundsResponseDtoResponseItem = [6]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "port",
	4: "network",
	5: "security",
}

// Decode decodes GetInboundsResponseDtoResponseItem from json.
func (s *GetInboundsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Port = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetInboundsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodeUserUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodeUserUsageByRangeResponseDto from json.
func (s *GetNodeUserUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodeUserUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodeUserUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodeUserUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodeUserUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodeUserUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem = [5]string{
	0: "userUuid",
	1: "username",
	2: "nodeUuid",
	3: "total",
	4: "date",
}

// Decode decodes GetNodeUserUsageByRangeResponseDtoResponseItem from json.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodeUserUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodeUserUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesRealtimeUsageResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesRealtimeUsageResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesRealtimeUsageResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesRealtimeUsageResponseDto from json.
func (s *GetNodesRealtimeUsageResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesRealtimeUsageResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodesRealtimeUsageResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesRealtimeUsageResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesRealtimeUsageResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesRealtimeUsageResponseDto) {
					name = jsonFieldsNameOfGetNodesRealtimeUsageResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesRealtimeUsageResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesRealtimeUsageResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("downloadBytes")
		e.Float64(s.DownloadBytes)
	}
	{
		e.FieldStart("uploadBytes")
		e.Float64(s.UploadBytes)
	}
	{
		e.FieldStart("totalBytes")
		e.Float64(s.TotalBytes)
	}
	{
		e.FieldStart("downloadSpeedBps")
		e.Float64(s.DownloadSpeedBps)
	}
	{
		e.FieldStart("uploadSpeedBps")
		e.Float64(s.UploadSpeedBps)
	}
	{
		e.FieldStart("totalSpeedBps")
		e.Float64(s.TotalSpeedBps)
	}
}

var jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem = [9]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "countryCode",
	3: "downloadBytes",
	4: "uploadBytes",
	5: "totalBytes",
	6: "downloadSpeedBps",
	7: "uploadSpeedBps",
	8: "totalSpeedBps",
}

// Decode decodes GetNodesRealtimeUsageResponseDtoResponseItem from json.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesRealtimeUsageResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "downloadBytes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.DownloadBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadBytes\"")
			}
		case "uploadBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UploadBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadBytes\"")
			}
		case "totalBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.TotalBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBytes\"")
			}
		case "downloadSpeedBps":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.DownloadSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadSpeedBps\"")
			}
		case "uploadSpeedBps":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.UploadSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadSpeedBps\"")
			}
		case "totalSpeedBps":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpeedBps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesRealtimeUsageResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesStatisticsResponseDto from json.
func (s *GetNodesStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDto) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastSevenDays")
		e.ArrStart()
		for _, elem := range s.LastSevenDays {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse = [1]string{
	0: "lastSevenDays",
}

// Decode decodes GetNodesStatisticsResponseDtoResponse from json.
func (s *GetNodesStatisticsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastSevenDays":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.LastSevenDays = make([]GetNodesStatisticsResponseDtoResponseLastSevenDaysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesStatisticsResponseDtoResponseLastSevenDaysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LastSevenDays = append(s.LastSevenDays, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSevenDays\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
	{
		e.FieldStart("totalBytes")
		e.Str(s.TotalBytes)
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem = [3]string{
	0: "nodeName",
	1: "date",
	2: "totalBytes",
}

// Decode decodes GetNodesStatisticsResponseDtoResponseLastSevenDaysItem from json.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDtoResponseLastSevenDaysItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "totalBytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TotalBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDtoResponseLastSevenDaysItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesUsageByRangeResponseDto from json.
func (s *GetNodesUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodesUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetNodesUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("totalDownload")
		e.Float64(s.TotalDownload)
	}
	{
		e.FieldStart("totalUpload")
		e.Float64(s.TotalUpload)
	}
	{
		e.FieldStart("humanReadableTotal")
		e.Str(s.HumanReadableTotal)
	}
	{
		e.FieldStart("humanReadableTotalDownload")
		e.Str(s.HumanReadableTotalDownload)
	}
	{
		e.FieldStart("humanReadableTotalUpload")
		e.Str(s.HumanReadableTotalUpload)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem = [9]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "total",
	3: "totalDownload",
	4: "totalUpload",
	5: "humanReadableTotal",
	6: "humanReadableTotalDownload",
	7: "humanReadableTotalUpload",
	8: "date",
}

// Decode decodes GetNodesUsageByRangeResponseDtoResponseItem from json.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "totalDownload":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalDownload = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDownload\"")
			}
		case "totalUpload":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.TotalUpload = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUpload\"")
			}
		case "humanReadableTotal":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotal\"")
			}
		case "humanReadableTotalDownload":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotalDownload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotalDownload\"")
			}
		case "humanReadableTotalUpload":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotalUpload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotalUpload\"")
			}
		case "date":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetOneHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetOneHostResponseDto from json.
func (s *GetOneHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDto) {
					name = jsonFieldsNameOfGetOneHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfGetOneHostResponseDtoResponse = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes GetOneHostResponseDtoResponse from json.
func (s *GetOneHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDtoResponse) {
					name = jsonFieldsNameOfGetOneHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneHostResponseDtoResponseSecurityLayer as json.
func (s GetOneHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetOneHostResponseDtoResponseSecurityLayer from json.
func (s *GetOneHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetOneHostResponseDtoResponseSecurityLayer(v) {
	case GetOneHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = GetOneHostResponseDtoResponseSecurityLayerDEFAULT
	case GetOneHostResponseDtoResponseSecurityLayerTLS:
		*s = GetOneHostResponseDtoResponseSecurityLayerTLS
	case GetOneHostResponseDtoResponseSecurityLayerNONE:
		*s = GetOneHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = GetOneHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetOneHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetOneNodeResponseDto from json.
func (s *GetOneNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDto) {
					name = jsonFieldsNameOfGetOneNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("excludedInbounds")
		e.ArrStart()
		for _, elem := range s.ExcludedInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponse = [28]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "xrayUptime",
	13: "isTrafficTrackingActive",
	14: "trafficResetDay",
	15: "trafficLimitBytes",
	16: "trafficUsedBytes",
	17: "notifyPercent",
	18: "usersOnline",
	19: "viewPosition",
	20: "countryCode",
	21: "consumptionMultiplier",
	22: "cpuCount",
	23: "cpuModel",
	24: "totalRam",
	25: "createdAt",
	26: "updatedAt",
	27: "excludedInbounds",
}

// Decode decodes GetOneNodeResponseDtoResponse from json.
func (s *GetOneNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "excludedInbounds":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				s.ExcludedInbounds = make([]GetOneNodeResponseDtoResponseExcludedInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetOneNodeResponseDtoResponseExcludedInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponse) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponseExcludedInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponseExcludedInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponseExcludedInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes GetOneNodeResponseDtoResponseExcludedInboundsItem from json.
func (s *GetOneNodeResponseDtoResponseExcludedInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponseExcludedInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponseExcludedInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponseExcludedInboundsItem) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponseExcludedInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponseExcludedInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponseExcludedInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPubKeyResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPubKeyResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetPubKeyResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetPubKeyResponseDto from json.
func (s *GetPubKeyResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPubKeyResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPubKeyResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPubKeyResponseDto) {
					name = jsonFieldsNameOfGetPubKeyResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPubKeyResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPubKeyResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPubKeyResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPubKeyResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pubKey")
		e.Str(s.PubKey)
	}
}

var jsonFieldsNameOfGetPubKeyResponseDtoResponse = [1]string{
	0: "pubKey",
}

// Decode decodes GetPubKeyResponseDtoResponse from json.
func (s *GetPubKeyResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPubKeyResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pubKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PubKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pubKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPubKeyResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPubKeyResponseDtoResponse) {
					name = jsonFieldsNameOfGetPubKeyResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPubKeyResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPubKeyResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetStatsResponseDto from json.
func (s *GetStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDto) {
					name = jsonFieldsNameOfGetStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cpu")
		s.CPU.Encode(e)
	}
	{
		e.FieldStart("memory")
		s.Memory.Encode(e)
	}
	{
		e.FieldStart("uptime")
		e.Float64(s.Uptime)
	}
	{
		e.FieldStart("timestamp")
		e.Float64(s.Timestamp)
	}
	{
		e.FieldStart("users")
		s.Users.Encode(e)
	}
	{
		e.FieldStart("onlineStats")
		s.OnlineStats.Encode(e)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponse = [6]string{
	0: "cpu",
	1: "memory",
	2: "uptime",
	3: "timestamp",
	4: "users",
	5: "onlineStats",
}

// Decode decodes GetStatsResponseDtoResponse from json.
func (s *GetStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		case "memory":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "uptime":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Uptime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Timestamp = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Users.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "onlineStats":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.OnlineStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineStats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseCPU) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseCPU) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cores")
		e.Float64(s.Cores)
	}
	{
		e.FieldStart("physicalCores")
		e.Float64(s.PhysicalCores)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseCPU = [2]string{
	0: "cores",
	1: "physicalCores",
}

// Decode decodes GetStatsResponseDtoResponseCPU from json.
func (s *GetStatsResponseDtoResponseCPU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseCPU to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cores":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Cores = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cores\"")
			}
		case "physicalCores":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.PhysicalCores = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalCores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseCPU")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseCPU) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseCPU[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseCPU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseCPU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseMemory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseMemory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("free")
		e.Float64(s.Free)
	}
	{
		e.FieldStart("used")
		e.Float64(s.Used)
	}
	{
		e.FieldStart("active")
		e.Float64(s.Active)
	}
	{
		e.FieldStart("available")
		e.Float64(s.Available)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseMemory = [5]string{
	0: "total",
	1: "free",
	2: "used",
	3: "active",
	4: "available",
}

// Decode decodes GetStatsResponseDtoResponseMemory from json.
func (s *GetStatsResponseDtoResponseMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseMemory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "free":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Free = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free\"")
			}
		case "used":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Used = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Active = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "available":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Available = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseMemory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseMemory) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseMemory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseOnlineStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastDay")
		e.Float64(s.LastDay)
	}
	{
		e.FieldStart("lastWeek")
		e.Float64(s.LastWeek)
	}
	{
		e.FieldStart("neverOnline")
		e.Float64(s.NeverOnline)
	}
	{
		e.FieldStart("onlineNow")
		e.Float64(s.OnlineNow)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats = [4]string{
	0: "lastDay",
	1: "lastWeek",
	2: "neverOnline",
	3: "onlineNow",
}

// Decode decodes GetStatsResponseDtoResponseOnlineStats from json.
func (s *GetStatsResponseDtoResponseOnlineStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseOnlineStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastDay":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.LastDay = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastDay\"")
			}
		case "lastWeek":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.LastWeek = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastWeek\"")
			}
		case "neverOnline":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.NeverOnline = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neverOnline\"")
			}
		case "onlineNow":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.OnlineNow = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineNow\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseOnlineStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseUsers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseUsers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("statusCounts")
		s.StatusCounts.Encode(e)
	}
	{
		e.FieldStart("totalUsers")
		e.Float64(s.TotalUsers)
	}
	{
		e.FieldStart("totalTrafficBytes")
		e.Str(s.TotalTrafficBytes)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseUsers = [3]string{
	0: "statusCounts",
	1: "totalUsers",
	2: "totalTrafficBytes",
}

// Decode decodes GetStatsResponseDtoResponseUsers from json.
func (s *GetStatsResponseDtoResponseUsers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseUsers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCounts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.StatusCounts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCounts\"")
			}
		case "totalUsers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalUsers = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUsers\"")
			}
		case "totalTrafficBytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TotalTrafficBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalTrafficBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseUsers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseUsers) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseUsers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseUsers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseUsers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes GetStatsResponseDtoResponseUsersStatusCounts from json.
func (s *GetStatsResponseDtoResponseUsersStatusCounts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseUsersStatusCounts to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseUsersStatusCounts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseUsersStatusCounts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetStatusResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetStatusResponseDto from json.
func (s *GetStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatusResponseDto) {
					name = jsonFieldsNameOfGetStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatusResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatusResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isLoginAllowed")
		e.Bool(s.IsLoginAllowed)
	}
	{
		e.FieldStart("isRegisterAllowed")
		e.Bool(s.IsRegisterAllowed)
	}
	{
		e.FieldStart("tgAuth")
		s.TgAuth.Encode(e)
	}
}

var jsonFieldsNameOfGetStatusResponseDtoResponse = [3]string{
	0: "isLoginAllowed",
	1: "isRegisterAllowed",
	2: "tgAuth",
}

// Decode decodes GetStatusResponseDtoResponse from json.
func (s *GetStatusResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isLoginAllowed":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsLoginAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isLoginAllowed\"")
			}
		case "isRegisterAllowed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsRegisterAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRegisterAllowed\"")
			}
		case "tgAuth":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TgAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tgAuth\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatusResponseDtoResponse) {
					name = jsonFieldsNameOfGetStatusResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatusResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatusResponseDtoResponseTgAuth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatusResponseDtoResponseTgAuth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("botId")
		e.Float64(s.BotId)
	}
}

var jsonFieldsNameOfGetStatusResponseDtoResponseTgAuth = [1]string{
	0: "botId",
}

// Decode decodes GetStatusResponseDtoResponseTgAuth from json.
func (s *GetStatusResponseDtoResponseTgAuth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDtoResponseTgAuth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "botId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.BotId = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"botId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDtoResponseTgAuth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatusResponseDtoResponseTgAuth) {
					name = jsonFieldsNameOfGetStatusResponseDtoResponseTgAuth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatusResponseDtoResponseTgAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDtoResponseTgAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionByUsernameResponseDto from json.
func (s *GetSubscriptionByUsernameResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse = [5]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponse from json.
func (s *GetSubscriptionByUsernameResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUser from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUsernameResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUsernameResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionInfoResponseDto from json.
func (s *GetSubscriptionInfoResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse = [5]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponse from json.
func (s *GetSubscriptionInfoResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionInfoResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUser from json.
func (s *GetSubscriptionInfoResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionInfoResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionInfoResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionInfoResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionInfoResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionSettingsResponseDto from json.
func (s *GetSubscriptionSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileTitle")
		e.Str(s.ProfileTitle)
	}
	{
		e.FieldStart("supportLink")
		e.Str(s.SupportLink)
	}
	{
		e.FieldStart("profileUpdateInterval")
		e.Int(s.ProfileUpdateInterval)
	}
	{
		e.FieldStart("isProfileWebpageUrlEnabled")
		e.Bool(s.IsProfileWebpageUrlEnabled)
	}
	{
		e.FieldStart("serveJsonAtBaseSubscription")
		e.Bool(s.ServeJsonAtBaseSubscription)
	}
	{
		e.FieldStart("addUsernameToBaseSubscription")
		e.Bool(s.AddUsernameToBaseSubscription)
	}
	{
		e.FieldStart("isShowCustomRemarks")
		e.Bool(s.IsShowCustomRemarks)
	}
	{
		e.FieldStart("happAnnounce")
		s.HappAnnounce.Encode(e)
	}
	{
		e.FieldStart("happRouting")
		s.HappRouting.Encode(e)
	}
	{
		e.FieldStart("expiredUsersRemarks")
		e.ArrStart()
		for _, elem := range s.ExpiredUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("limitedUsersRemarks")
		e.ArrStart()
		for _, elem := range s.LimitedUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("disabledUsersRemarks")
		e.ArrStart()
		for _, elem := range s.DisabledUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("customResponseHeaders")
		s.CustomResponseHeaders.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse = [16]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "createdAt",
	15: "updatedAt",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponse from json.
func (s *GetSubscriptionSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProfileTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SupportLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProfileUpdateInterval = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsProfileWebpageUrlEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ServeJsonAtBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AddUsernameToBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsShowCustomRemarks = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "createdAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (s *GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetTemplateResponseDto from json.
func (s *GetTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplateResponseDto) {
					name = jsonFieldsNameOfGetTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplateResponseDtoResponse = [4]string{
	0: "uuid",
	1: "templateType",
	2: "templateJson",
	3: "encodedTemplateYaml",
}

// Decode decodes GetTemplateResponseDtoResponse from json.
func (s *GetTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfGetTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTemplateResponseDtoResponseTemplateType as json.
func (s GetTemplateResponseDtoResponseTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetTemplateResponseDtoResponseTemplateType from json.
func (s *GetTemplateResponseDtoResponseTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDtoResponseTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetTemplateResponseDtoResponseTemplateType(v) {
	case GetTemplateResponseDtoResponseTemplateTypeSTASH:
		*s = GetTemplateResponseDtoResponseTemplateTypeSTASH
	case GetTemplateResponseDtoResponseTemplateTypeSINGBOX:
		*s = GetTemplateResponseDtoResponseTemplateTypeSINGBOX
	case GetTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY:
		*s = GetTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY
	case GetTemplateResponseDtoResponseTemplateTypeMIHOMO:
		*s = GetTemplateResponseDtoResponseTemplateTypeMIHOMO
	case GetTemplateResponseDtoResponseTemplateTypeXRAYJSON:
		*s = GetTemplateResponseDtoResponseTemplateTypeXRAYJSON
	case GetTemplateResponseDtoResponseTemplateTypeCLASH:
		*s = GetTemplateResponseDtoResponseTemplateTypeCLASH
	default:
		*s = GetTemplateResponseDtoResponseTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTemplateResponseDtoResponseTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDtoResponseTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserByTagResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByTagResponseDto from json.
func (s *GetUserByTagResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserByTagResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTagResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDto) {
					name = jsonFieldsNameOfGetUserByTagResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItem = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes GetUserByTagResponseDtoResponseItem from json.
func (s *GetUserByTagResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]GetUserByTagResponseDtoResponseItemActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTagResponseDtoResponseItemActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes GetUserByTagResponseDtoResponseItemActiveUserInboundsItem from json.
func (s *GetUserByTagResponseDtoResponseItemActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveUserInboundsItem) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByTagResponseDtoResponseItemHapp from json.
func (s *GetUserByTagResponseDtoResponseItemHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes GetUserByTagResponseDtoResponseItemLastConnectedNode from json.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemStatus as json.
func (s GetUserByTagResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTagResponseDtoResponseItemStatus from json.
func (s *GetUserByTagResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTagResponseDtoResponseItemStatus(v) {
	case GetUserByTagResponseDtoResponseItemStatusACTIVE:
		*s = GetUserByTagResponseDtoResponseItemStatusACTIVE
	case GetUserByTagResponseDtoResponseItemStatusDISABLED:
		*s = GetUserByTagResponseDtoResponseItemStatusDISABLED
	case GetUserByTagResponseDtoResponseItemStatusLIMITED:
		*s = GetUserByTagResponseDtoResponseItemStatusLIMITED
	case GetUserByTagResponseDtoResponseItemStatusEXPIRED:
		*s = GetUserByTagResponseDtoResponseItemStatusEXPIRED
	default:
		*s = GetUserByTagResponseDtoResponseItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTagResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy as json.
func (s GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy from json.
func (s *GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTagResponseDtoResponseItemTrafficLimitStrategy(v) {
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyNORESET:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyNORESET
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyDAY:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyDAY
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyWEEK:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyWEEK
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyMONTH:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyMONTH
	default:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByUuidResponseDto from json.
func (s *GetUserByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDto) {
					name = jsonFieldsNameOfGetUserByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponse = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes GetUserByUuidResponseDtoResponse from json.
func (s *GetUserByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]GetUserByUuidResponseDtoResponseActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByUuidResponseDtoResponseActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponseActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponseActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponseActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes GetUserByUuidResponseDtoResponseActiveUserInboundsItem from json.
func (s *GetUserByUuidResponseDtoResponseActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponseActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponseActiveUserInboundsItem) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponseActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponseActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByUuidResponseDtoResponseHapp from json.
func (s *GetUserByUuidResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes GetUserByUuidResponseDtoResponseLastConnectedNode from json.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseStatus as json.
func (s GetUserByUuidResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUuidResponseDtoResponseStatus from json.
func (s *GetUserByUuidResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUuidResponseDtoResponseStatus(v) {
	case GetUserByUuidResponseDtoResponseStatusACTIVE:
		*s = GetUserByUuidResponseDtoResponseStatusACTIVE
	case GetUserByUuidResponseDtoResponseStatusDISABLED:
		*s = GetUserByUuidResponseDtoResponseStatusDISABLED
	case GetUserByUuidResponseDtoResponseStatusLIMITED:
		*s = GetUserByUuidResponseDtoResponseStatusLIMITED
	case GetUserByUuidResponseDtoResponseStatusEXPIRED:
		*s = GetUserByUuidResponseDtoResponseStatusEXPIRED
	default:
		*s = GetUserByUuidResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUuidResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy as json.
func (s GetUserByUuidResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy from json.
func (s *GetUserByUuidResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUuidResponseDtoResponseTrafficLimitStrategy(v) {
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyNORESET
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyDAY:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyDAY
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyWEEK
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUuidResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserHwidDevicesResponseDto from json.
func (s *GetUserHwidDevicesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserHwidDevicesResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserHwidDevicesResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDto) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes GetUserHwidDevicesResponseDtoResponseItem from json.
func (s *GetUserHwidDevicesResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserUsageByRangeResponseDto from json.
func (s *GetUserUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetUserUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem = [5]string{
	0: "userUuid",
	1: "nodeUuid",
	2: "nodeName",
	3: "total",
	4: "date",
}

// Decode decodes GetUserUsageByRangeResponseDtoResponseItem from json.
func (s *GetUserUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfLoginRequestDto = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes LoginRequestDto from json.
func (s *LoginRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginRequestDto) {
					name = jsonFieldsNameOfLoginRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfLoginResponseDto = [1]string{
	0: "response",
}

// Decode decodes LoginResponseDto from json.
func (s *LoginResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginResponseDto) {
					name = jsonFieldsNameOfLoginResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfLoginResponseDtoResponse = [1]string{
	0: "accessToken",
}

// Decode decodes LoginResponseDtoResponse from json.
func (s *LoginResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginResponseDtoResponse) {
					name = jsonFieldsNameOfLoginResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateAllInboundsResponseDtoResponseLastConnectedNode as json.
func (o NilActivateAllInboundsResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ActivateAllInboundsResponseDtoResponseLastConnectedNode from json.
func (o *NilActivateAllInboundsResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilActivateAllInboundsResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ActivateAllInboundsResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilActivateAllInboundsResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilActivateAllInboundsResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o NilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DisableUserResponseDtoResponseLastConnectedNode as json.
func (o NilDisableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DisableUserResponseDtoResponseLastConnectedNode from json.
func (o *NilDisableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDisableUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v DisableUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDisableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDisableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseLastConnectedNode as json.
func (o NilEnableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnableUserResponseDtoResponseLastConnectedNode from json.
func (o *NilEnableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilEnableUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnableUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilEnableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilEnableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o NilFloat64) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *NilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStatusResponseDtoResponseTgAuth as json.
func (o NilGetStatusResponseDtoResponseTgAuth) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetStatusResponseDtoResponseTgAuth from json.
func (o *NilGetStatusResponseDtoResponseTgAuth) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetStatusResponseDtoResponseTgAuth to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetStatusResponseDtoResponseTgAuth
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetStatusResponseDtoResponseTgAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetStatusResponseDtoResponseTgAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders as json.
func (o NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (o *NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemLastConnectedNode as json.
func (o NilGetUserByTagResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByTagResponseDtoResponseItemLastConnectedNode from json.
func (o *NilGetUserByTagResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByTagResponseDtoResponseItemLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByTagResponseDtoResponseItemLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByTagResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByTagResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseLastConnectedNode as json.
func (o NilGetUserByUuidResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByUuidResponseDtoResponseLastConnectedNode from json.
func (o *NilGetUserByUuidResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByUuidResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByUuidResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByUuidResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByUuidResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseLastConnectedNode as json.
func (o NilResetUserTrafficResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResetUserTrafficResponseDtoResponseLastConnectedNode from json.
func (o *NilResetUserTrafficResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilResetUserTrafficResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ResetUserTrafficResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilResetUserTrafficResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilResetUserTrafficResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode as json.
func (o NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode from json.
func (o *NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RevokeUserSubscriptionResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders as json.
func (o NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (o *NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoLastConnectedNode as json.
func (o NilUserDtoLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserDtoLastConnectedNode from json.
func (o *NilUserDtoLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUserDtoLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UserDtoLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUserDtoLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUserDtoLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateAllInboundsResponseDtoResponseStatus as json.
func (o OptActivateAllInboundsResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ActivateAllInboundsResponseDtoResponseStatus from json.
func (o *OptActivateAllInboundsResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivateAllInboundsResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActivateAllInboundsResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActivateAllInboundsResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy as json.
func (o OptActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ActivateAllInboundsResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptActivateAllInboundsResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptActivateAllInboundsResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoStatus as json.
func (o OptBulkAllUpdateUsersRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkAllUpdateUsersRequestDtoStatus from json.
func (o *OptBulkAllUpdateUsersRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkAllUpdateUsersRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkAllUpdateUsersRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkAllUpdateUsersRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy as json.
func (o OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy from json.
func (o *OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteUsersByStatusRequestDtoStatus as json.
func (o OptBulkDeleteUsersByStatusRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDeleteUsersByStatusRequestDtoStatus from json.
func (o *OptBulkDeleteUsersByStatusRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDeleteUsersByStatusRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDeleteUsersByStatusRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDeleteUsersByStatusRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDisableHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDisableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkEnableHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkEnableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsStatus as json.
func (o OptBulkUpdateUsersRequestDtoFieldsStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsStatus from json.
func (o *OptBulkUpdateUsersRequestDtoFieldsStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkUpdateUsersRequestDtoFieldsStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkUpdateUsersRequestDtoFieldsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkUpdateUsersRequestDtoFieldsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy as json.
func (o OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy from json.
func (o *OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoSecurityLayer as json.
func (o OptCreateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoSecurityLayer from json.
func (o *OptCreateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateHostRequestDtoSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostResponseDtoResponseSecurityLayer as json.
func (o OptCreateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostResponseDtoResponseSecurityLayer from json.
func (o *OptCreateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoStatus as json.
func (o OptCreateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserRequestDtoStatus from json.
func (o *OptCreateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DisableUserResponseDtoResponseStatus as json.
func (o OptDisableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DisableUserResponseDtoResponseStatus from json.
func (o *OptDisableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDisableUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDisableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDisableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptDisableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DisableUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptDisableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDisableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDisableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDisableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseStatus as json.
func (o OptEnableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnableUserResponseDtoResponseStatus from json.
func (o *OptEnableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnableUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptEnableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnableUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptEnableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptGetAllHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetAllHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptGetAllHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetAllHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetAllHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetAllHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneHostResponseDtoResponseSecurityLayer as json.
func (o OptGetOneHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetOneHostResponseDtoResponseSecurityLayer from json.
func (o *OptGetOneHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetOneHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetOneHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetOneHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemStatus as json.
func (o OptGetUserByTagResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTagResponseDtoResponseItemStatus from json.
func (o *OptGetUserByTagResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTagResponseDtoResponseItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTagResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTagResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy as json.
func (o OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy from json.
func (o *OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseStatus as json.
func (o OptGetUserByUuidResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUuidResponseDtoResponseStatus from json.
func (o *OptGetUserByUuidResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUuidResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUuidResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUuidResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy as json.
func (o OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoAlpn as json.
func (o OptNilCreateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoAlpn from json.
func (o *OptNilCreateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateHostRequestDtoAlpn to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateHostRequestDtoAlpn
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoFingerprint as json.
func (o OptNilCreateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoFingerprint from json.
func (o *OptNilCreateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateHostRequestDtoFingerprint to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateHostRequestDtoFingerprint
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoAlpn as json.
func (o OptNilUpdateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoAlpn from json.
func (o *OptNilUpdateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpdateHostRequestDtoAlpn to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateHostRequestDtoAlpn
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpdateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpdateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoFingerprint as json.
func (o OptNilUpdateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoFingerprint from json.
func (o *OptNilUpdateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpdateHostRequestDtoFingerprint to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateHostRequestDtoFingerprint
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpdateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpdateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseStatus as json.
func (o OptResetUserTrafficResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResetUserTrafficResponseDtoResponseStatus from json.
func (o *OptResetUserTrafficResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResetUserTrafficResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResetUserTrafficResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResetUserTrafficResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy as json.
func (o OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseStatus as json.
func (o OptRevokeUserSubscriptionResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseStatus from json.
func (o *OptRevokeUserSubscriptionResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRevokeUserSubscriptionResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRevokeUserSubscriptionResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRevokeUserSubscriptionResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy as json.
func (o OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoSecurityLayer as json.
func (o OptUpdateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoSecurityLayer from json.
func (o *OptUpdateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostRequestDtoSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostResponseDtoResponseSecurityLayer as json.
func (o OptUpdateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostResponseDtoResponseSecurityLayer from json.
func (o *OptUpdateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders as json.
func (o OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders from json.
func (o *OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders to nil")
	}
	o.Set = true
	o.Value = make(UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoStatus as json.
func (o OptUpdateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserRequestDtoStatus from json.
func (o *OptUpdateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoTrafficLimitStrategy as json.
func (o OptUpdateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserRequestDtoTrafficLimitStrategy from json.
func (o *OptUpdateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoStatus as json.
func (o OptUserDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserDtoStatus from json.
func (o *OptUserDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoTrafficLimitStrategy as json.
func (o OptUserDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserDtoTrafficLimitStrategy from json.
func (o *OptUserDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfRegisterRequestDto = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes RegisterRequestDto from json.
func (s *RegisterRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterRequestDto) {
					name = jsonFieldsNameOfRegisterRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRegisterResponseDto = [1]string{
	0: "response",
}

// Decode decodes RegisterResponseDto from json.
func (s *RegisterResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterResponseDto) {
					name = jsonFieldsNameOfRegisterResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfRegisterResponseDtoResponse = [1]string{
	0: "accessToken",
}

// Decode decodes RegisterResponseDtoResponse from json.
func (s *RegisterResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterResponseDtoResponse) {
					name = jsonFieldsNameOfRegisterResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveInboundFromNodesRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveInboundFromNodesRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
}

var jsonFieldsNameOfRemoveInboundFromNodesRequestDto = [1]string{
	0: "inboundUuid",
}

// Decode decodes RemoveInboundFromNodesRequestDto from json.
func (s *RemoveInboundFromNodesRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveInboundFromNodesRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveInboundFromNodesRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveInboundFromNodesRequestDto) {
					name = jsonFieldsNameOfRemoveInboundFromNodesRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveInboundFromNodesRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveInboundFromNodesRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveInboundFromNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveInboundFromNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRemoveInboundFromNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes RemoveInboundFromNodesResponseDto from json.
func (s *RemoveInboundFromNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveInboundFromNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveInboundFromNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveInboundFromNodesResponseDto) {
					name = jsonFieldsNameOfRemoveInboundFromNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveInboundFromNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveInboundFromNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveInboundFromNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveInboundFromNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isSuccess")
		e.Bool(s.IsSuccess)
	}
}

var jsonFieldsNameOfRemoveInboundFromNodesResponseDtoResponse = [1]string{
	0: "isSuccess",
}

// Decode decodes RemoveInboundFromNodesResponseDtoResponse from json.
func (s *RemoveInboundFromNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveInboundFromNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isSuccess":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsSuccess = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSuccess\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveInboundFromNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveInboundFromNodesResponseDtoResponse) {
					name = jsonFieldsNameOfRemoveInboundFromNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveInboundFromNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveInboundFromNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveInboundFromUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveInboundFromUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
}

var jsonFieldsNameOfRemoveInboundFromUsersRequestDto = [1]string{
	0: "inboundUuid",
}

// Decode decodes RemoveInboundFromUsersRequestDto from json.
func (s *RemoveInboundFromUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveInboundFromUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveInboundFromUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveInboundFromUsersRequestDto) {
					name = jsonFieldsNameOfRemoveInboundFromUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveInboundFromUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveInboundFromUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveInboundFromUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveInboundFromUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRemoveInboundFromUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes RemoveInboundFromUsersResponseDto from json.
func (s *RemoveInboundFromUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveInboundFromUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveInboundFromUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveInboundFromUsersResponseDto) {
					name = jsonFieldsNameOfRemoveInboundFromUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveInboundFromUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveInboundFromUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveInboundFromUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveInboundFromUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isSuccess")
		e.Bool(s.IsSuccess)
	}
}

var jsonFieldsNameOfRemoveInboundFromUsersResponseDtoResponse = [1]string{
	0: "isSuccess",
}

// Decode decodes RemoveInboundFromUsersResponseDtoResponse from json.
func (s *RemoveInboundFromUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveInboundFromUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isSuccess":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsSuccess = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSuccess\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveInboundFromUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveInboundFromUsersResponseDtoResponse) {
					name = jsonFieldsNameOfRemoveInboundFromUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveInboundFromUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveInboundFromUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hosts")
		e.ArrStart()
		for _, elem := range s.Hosts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderHostRequestDto = [1]string{
	0: "hosts",
}

// Decode decodes ReorderHostRequestDto from json.
func (s *ReorderHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Hosts = make([]ReorderHostRequestDtoHostsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderHostRequestDtoHostsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostRequestDto) {
					name = jsonFieldsNameOfReorderHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostRequestDtoHostsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostRequestDtoHostsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
}

var jsonFieldsNameOfReorderHostRequestDtoHostsItem = [2]string{
	0: "viewPosition",
	1: "uuid",
}

// Decode decodes ReorderHostRequestDtoHostsItem from json.
func (s *ReorderHostRequestDtoHostsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostRequestDtoHostsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "viewPosition":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostRequestDtoHostsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostRequestDtoHostsItem) {
					name = jsonFieldsNameOfReorderHostRequestDtoHostsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostRequestDtoHostsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostRequestDtoHostsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfReorderHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes ReorderHostResponseDto from json.
func (s *ReorderHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostResponseDto) {
					name = jsonFieldsNameOfReorderHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isUpdated")
		e.Bool(s.IsUpdated)
	}
}

var jsonFieldsNameOfReorderHostResponseDtoResponse = [1]string{
	0: "isUpdated",
}

// Decode decodes ReorderHostResponseDtoResponse from json.
func (s *ReorderHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isUpdated":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsUpdated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isUpdated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostResponseDtoResponse) {
					name = jsonFieldsNameOfReorderHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeRequestDto = [1]string{
	0: "nodes",
}

// Decode decodes ReorderNodeRequestDto from json.
func (s *ReorderNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]ReorderNodeRequestDtoNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeRequestDtoNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeRequestDto) {
					name = jsonFieldsNameOfReorderNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeRequestDtoNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeRequestDtoNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
}

var jsonFieldsNameOfReorderNodeRequestDtoNodesItem = [2]string{
	0: "viewPosition",
	1: "uuid",
}

// Decode decodes ReorderNodeRequestDtoNodesItem from json.
func (s *ReorderNodeRequestDtoNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeRequestDtoNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "viewPosition":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeRequestDtoNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeRequestDtoNodesItem) {
					name = jsonFieldsNameOfReorderNodeRequestDtoNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeRequestDtoNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeRequestDtoNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes ReorderNodeResponseDto from json.
func (s *ReorderNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]ReorderNodeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDto) {
					name = jsonFieldsNameOfReorderNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("excludedInbounds")
		e.ArrStart()
		for _, elem := range s.ExcludedInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItem = [28]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "xrayUptime",
	13: "isTrafficTrackingActive",
	14: "trafficResetDay",
	15: "trafficLimitBytes",
	16: "trafficUsedBytes",
	17: "notifyPercent",
	18: "usersOnline",
	19: "viewPosition",
	20: "countryCode",
	21: "consumptionMultiplier",
	22: "cpuCount",
	23: "cpuModel",
	24: "totalRam",
	25: "createdAt",
	26: "updatedAt",
	27: "excludedInbounds",
}

// Decode decodes ReorderNodeResponseDtoResponseItem from json.
func (s *ReorderNodeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "excludedInbounds":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				s.ExcludedInbounds = make([]ReorderNodeResponseDtoResponseItemExcludedInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeResponseDtoResponseItemExcludedInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItem) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemExcludedInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItemExcludedInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItemExcludedInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes ReorderNodeResponseDtoResponseItemExcludedInboundsItem from json.
func (s *ReorderNodeResponseDtoResponseItemExcludedInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItemExcludedInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItemExcludedInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItemExcludedInboundsItem) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItemExcludedInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemExcludedInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItemExcludedInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDto = [1]string{
	0: "response",
}

// Decode decodes ResetUserTrafficResponseDto from json.
func (s *ResetUserTrafficResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDto) {
					name = jsonFieldsNameOfResetUserTrafficResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponse = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes ResetUserTrafficResponseDtoResponse from json.
func (s *ResetUserTrafficResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]ResetUserTrafficResponseDtoResponseActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResetUserTrafficResponseDtoResponseActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponse) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes ResetUserTrafficResponseDtoResponseActiveUserInboundsItem from json.
func (s *ResetUserTrafficResponseDtoResponseActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveUserInboundsItem) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes ResetUserTrafficResponseDtoResponseHapp from json.
func (s *ResetUserTrafficResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes ResetUserTrafficResponseDtoResponseLastConnectedNode from json.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseStatus as json.
func (s ResetUserTrafficResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResetUserTrafficResponseDtoResponseStatus from json.
func (s *ResetUserTrafficResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResetUserTrafficResponseDtoResponseStatus(v) {
	case ResetUserTrafficResponseDtoResponseStatusACTIVE:
		*s = ResetUserTrafficResponseDtoResponseStatusACTIVE
	case ResetUserTrafficResponseDtoResponseStatusDISABLED:
		*s = ResetUserTrafficResponseDtoResponseStatusDISABLED
	case ResetUserTrafficResponseDtoResponseStatusLIMITED:
		*s = ResetUserTrafficResponseDtoResponseStatusLIMITED
	case ResetUserTrafficResponseDtoResponseStatusEXPIRED:
		*s = ResetUserTrafficResponseDtoResponseStatusEXPIRED
	default:
		*s = ResetUserTrafficResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResetUserTrafficResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy as json.
func (s ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy from json.
func (s *ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResetUserTrafficResponseDtoResponseTrafficLimitStrategy(v) {
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyNORESET
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyDAY:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyDAY
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyWEEK
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartAllNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartAllNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRestartAllNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes RestartAllNodesResponseDto from json.
func (s *RestartAllNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartAllNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartAllNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartAllNodesResponseDto) {
					name = jsonFieldsNameOfRestartAllNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartAllNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartAllNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartAllNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartAllNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRestartAllNodesResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RestartAllNodesResponseDtoResponse from json.
func (s *RestartAllNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartAllNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartAllNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartAllNodesResponseDtoResponse) {
					name = jsonFieldsNameOfRestartAllNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartAllNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartAllNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRestartNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes RestartNodeResponseDto from json.
func (s *RestartNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartNodeResponseDto) {
					name = jsonFieldsNameOfRestartNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRestartNodeResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RestartNodeResponseDtoResponse from json.
func (s *RestartNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartNodeResponseDtoResponse) {
					name = jsonFieldsNameOfRestartNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDto = [1]string{
	0: "response",
}

// Decode decodes RevokeUserSubscriptionResponseDto from json.
func (s *RevokeUserSubscriptionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDto) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponse from json.
func (s *RevokeUserSubscriptionResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem from json.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseHapp from json.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode from json.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseStatus as json.
func (s RevokeUserSubscriptionResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseStatus from json.
func (s *RevokeUserSubscriptionResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RevokeUserSubscriptionResponseDtoResponseStatus(v) {
	case RevokeUserSubscriptionResponseDtoResponseStatusACTIVE:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusACTIVE
	case RevokeUserSubscriptionResponseDtoResponseStatusDISABLED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusDISABLED
	case RevokeUserSubscriptionResponseDtoResponseStatusLIMITED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusLIMITED
	case RevokeUserSubscriptionResponseDtoResponseStatusEXPIRED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusEXPIRED
	default:
		*s = RevokeUserSubscriptionResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RevokeUserSubscriptionResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy as json.
func (s RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy from json.
func (s *RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy(v) {
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyNORESET
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyDAY:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyDAY
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyWEEK
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
}

var jsonFieldsNameOfSetInboundToManyHostsRequestDto = [2]string{
	0: "uuids",
	1: "inboundUuid",
}

// Decode decodes SetInboundToManyHostsRequestDto from json.
func (s *SetInboundToManyHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsRequestDto) {
					name = jsonFieldsNameOfSetInboundToManyHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes SetInboundToManyHostsResponseDto from json.
func (s *SetInboundToManyHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]SetInboundToManyHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SetInboundToManyHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDto) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItem from json.
func (s *SetInboundToManyHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (s SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (s *SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetInboundToManyHostsResponseDtoResponseItemSecurityLayer(v) {
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerTLS
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
}

var jsonFieldsNameOfSetPortToManyHostsRequestDto = [2]string{
	0: "uuids",
	1: "port",
}

// Decode decodes SetPortToManyHostsRequestDto from json.
func (s *SetPortToManyHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsRequestDto) {
					name = jsonFieldsNameOfSetPortToManyHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes SetPortToManyHostsResponseDto from json.
func (s *SetPortToManyHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]SetPortToManyHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SetPortToManyHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDto) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItem from json.
func (s *SetPortToManyHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (s SetPortToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (s *SetPortToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetPortToManyHostsResponseDtoResponseItemSecurityLayer(v) {
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerTLS
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetPortToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUsernameNotFound = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUsernameNotFound from json.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUsernameNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUsernameNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelegramCallbackRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelegramCallbackRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		e.FieldStart("auth_date")
		e.Float64(s.AuthDate)
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
}

var jsonFieldsNameOfTelegramCallbackRequestDto = [7]string{
	0: "id",
	1: "first_name",
	2: "last_name",
	3: "username",
	4: "photo_url",
	5: "auth_date",
	6: "hash",
}

// Decode decodes TelegramCallbackRequestDto from json.
func (s *TelegramCallbackRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelegramCallbackRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "auth_date":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.AuthDate = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_date\"")
			}
		case "hash":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelegramCallbackRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelegramCallbackRequestDto) {
					name = jsonFieldsNameOfTelegramCallbackRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelegramCallbackRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelegramCallbackRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelegramCallbackResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelegramCallbackResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfTelegramCallbackResponseDto = [1]string{
	0: "response",
}

// Decode decodes TelegramCallbackResponseDto from json.
func (s *TelegramCallbackResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelegramCallbackResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelegramCallbackResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelegramCallbackResponseDto) {
					name = jsonFieldsNameOfTelegramCallbackResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelegramCallbackResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelegramCallbackResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelegramCallbackResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelegramCallbackResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfTelegramCallbackResponseDtoResponse = [1]string{
	0: "accessToken",
}

// Decode decodes TelegramCallbackResponseDtoResponse from json.
func (s *TelegramCallbackResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelegramCallbackResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelegramCallbackResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelegramCallbackResponseDtoResponse) {
					name = jsonFieldsNameOfTelegramCallbackResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelegramCallbackResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelegramCallbackResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigRequestDto) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateConfigRequestDto = [0]string{}

// Decode decodes UpdateConfigRequestDto from json.
func (s *UpdateConfigRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigRequestDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConfigResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateConfigResponseDto from json.
func (s *UpdateConfigResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigResponseDto) {
					name = jsonFieldsNameOfUpdateConfigResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
}

var jsonFieldsNameOfUpdateConfigResponseDtoResponse = [1]string{
	0: "config",
}

// Decode decodes UpdateConfigResponseDtoResponse from json.
func (s *UpdateConfigResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateConfigResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.InboundUuid.Set {
			e.FieldStart("inboundUuid")
			s.InboundUuid.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfUpdateHostRequestDto = [14]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "allowInsecure",
	11: "isDisabled",
	12: "securityLayer",
	13: "xHttpExtraParams",
}

// Decode decodes UpdateHostRequestDto from json.
func (s *UpdateHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			if err := func() error {
				s.InboundUuid.Reset()
				if err := s.InboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostRequestDto) {
					name = jsonFieldsNameOfUpdateHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoAlpn as json.
func (s UpdateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoAlpn from json.
func (s *UpdateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoAlpn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoAlpn(v) {
	case UpdateHostRequestDtoAlpnH3:
		*s = UpdateHostRequestDtoAlpnH3
	case UpdateHostRequestDtoAlpnH2:
		*s = UpdateHostRequestDtoAlpnH2
	case UpdateHostRequestDtoAlpnHTTP11:
		*s = UpdateHostRequestDtoAlpnHTTP11
	case UpdateHostRequestDtoAlpnH2HTTP11:
		*s = UpdateHostRequestDtoAlpnH2HTTP11
	case UpdateHostRequestDtoAlpnH3H2HTTP11:
		*s = UpdateHostRequestDtoAlpnH3H2HTTP11
	case UpdateHostRequestDtoAlpnH3H2:
		*s = UpdateHostRequestDtoAlpnH3H2
	default:
		*s = UpdateHostRequestDtoAlpn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoFingerprint as json.
func (s UpdateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoFingerprint from json.
func (s *UpdateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoFingerprint to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoFingerprint(v) {
	case UpdateHostRequestDtoFingerprintChrome:
		*s = UpdateHostRequestDtoFingerprintChrome
	case UpdateHostRequestDtoFingerprintFirefox:
		*s = UpdateHostRequestDtoFingerprintFirefox
	case UpdateHostRequestDtoFingerprintSafari:
		*s = UpdateHostRequestDtoFingerprintSafari
	case UpdateHostRequestDtoFingerprintIos:
		*s = UpdateHostRequestDtoFingerprintIos
	case UpdateHostRequestDtoFingerprintAndroid:
		*s = UpdateHostRequestDtoFingerprintAndroid
	case UpdateHostRequestDtoFingerprintEdge:
		*s = UpdateHostRequestDtoFingerprintEdge
	case UpdateHostRequestDtoFingerprintQq:
		*s = UpdateHostRequestDtoFingerprintQq
	case UpdateHostRequestDtoFingerprintRandom:
		*s = UpdateHostRequestDtoFingerprintRandom
	case UpdateHostRequestDtoFingerprintRandomized:
		*s = UpdateHostRequestDtoFingerprintRandomized
	default:
		*s = UpdateHostRequestDtoFingerprint(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoSecurityLayer as json.
func (s UpdateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoSecurityLayer from json.
func (s *UpdateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoSecurityLayer(v) {
	case UpdateHostRequestDtoSecurityLayerDEFAULT:
		*s = UpdateHostRequestDtoSecurityLayerDEFAULT
	case UpdateHostRequestDtoSecurityLayerTLS:
		*s = UpdateHostRequestDtoSecurityLayerTLS
	case UpdateHostRequestDtoSecurityLayerNONE:
		*s = UpdateHostRequestDtoSecurityLayerNONE
	default:
		*s = UpdateHostRequestDtoSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateHostResponseDto from json.
func (s *UpdateHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDto) {
					name = jsonFieldsNameOfUpdateHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inboundUuid")
		json.EncodeUUID(e, s.InboundUuid)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
}

var jsonFieldsNameOfUpdateHostResponseDtoResponse = [15]string{
	0:  "uuid",
	1:  "inboundUuid",
	2:  "viewPosition",
	3:  "remark",
	4:  "address",
	5:  "port",
	6:  "path",
	7:  "sni",
	8:  "host",
	9:  "alpn",
	10: "fingerprint",
	11: "allowInsecure",
	12: "isDisabled",
	13: "securityLayer",
	14: "xHttpExtraParams",
}

// Decode decodes UpdateHostResponseDtoResponse from json.
func (s *UpdateHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.InboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundUuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostResponseDtoResponseSecurityLayer as json.
func (s UpdateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostResponseDtoResponseSecurityLayer from json.
func (s *UpdateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostResponseDtoResponseSecurityLayer(v) {
	case UpdateHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = UpdateHostResponseDtoResponseSecurityLayerDEFAULT
	case UpdateHostResponseDtoResponseSecurityLayerTLS:
		*s = UpdateHostResponseDtoResponseSecurityLayerTLS
	case UpdateHostResponseDtoResponseSecurityLayerNONE:
		*s = UpdateHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = UpdateHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.IsTrafficTrackingActive.Set {
			e.FieldStart("isTrafficTrackingActive")
			s.IsTrafficTrackingActive.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.NotifyPercent.Set {
			e.FieldStart("notifyPercent")
			s.NotifyPercent.Encode(e)
		}
	}
	{
		if s.TrafficResetDay.Set {
			e.FieldStart("trafficResetDay")
			s.TrafficResetDay.Encode(e)
		}
	}
	{
		if s.ExcludedInbounds != nil {
			e.FieldStart("excludedInbounds")
			e.ArrStart()
			for _, elem := range s.ExcludedInbounds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CountryCode.Set {
			e.FieldStart("countryCode")
			s.CountryCode.Encode(e)
		}
	}
	{
		if s.ConsumptionMultiplier.Set {
			e.FieldStart("consumptionMultiplier")
			s.ConsumptionMultiplier.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNodeRequestDto = [11]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isTrafficTrackingActive",
	5:  "trafficLimitBytes",
	6:  "notifyPercent",
	7:  "trafficResetDay",
	8:  "excludedInbounds",
	9:  "countryCode",
	10: "consumptionMultiplier",
}

// Decode decodes UpdateNodeRequestDto from json.
func (s *UpdateNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isTrafficTrackingActive":
			if err := func() error {
				s.IsTrafficTrackingActive.Reset()
				if err := s.IsTrafficTrackingActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "notifyPercent":
			if err := func() error {
				s.NotifyPercent.Reset()
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "trafficResetDay":
			if err := func() error {
				s.TrafficResetDay.Reset()
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "excludedInbounds":
			if err := func() error {
				s.ExcludedInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		case "countryCode":
			if err := func() error {
				s.CountryCode.Reset()
				if err := s.CountryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			if err := func() error {
				s.ConsumptionMultiplier.Reset()
				if err := s.ConsumptionMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeRequestDto) {
					name = jsonFieldsNameOfUpdateNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateNodeResponseDto from json.
func (s *UpdateNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDto) {
					name = jsonFieldsNameOfUpdateNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("excludedInbounds")
		e.ArrStart()
		for _, elem := range s.ExcludedInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponse = [28]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "xrayUptime",
	13: "isTrafficTrackingActive",
	14: "trafficResetDay",
	15: "trafficLimitBytes",
	16: "trafficUsedBytes",
	17: "notifyPercent",
	18: "usersOnline",
	19: "viewPosition",
	20: "countryCode",
	21: "consumptionMultiplier",
	22: "cpuCount",
	23: "cpuModel",
	24: "totalRam",
	25: "createdAt",
	26: "updatedAt",
	27: "excludedInbounds",
}

// Decode decodes UpdateNodeResponseDtoResponse from json.
func (s *UpdateNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "excludedInbounds":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				s.ExcludedInbounds = make([]UpdateNodeResponseDtoResponseExcludedInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateNodeResponseDtoResponseExcludedInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExcludedInbounds = append(s.ExcludedInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludedInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponseExcludedInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponseExcludedInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponseExcludedInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes UpdateNodeResponseDtoResponseExcludedInboundsItem from json.
func (s *UpdateNodeResponseDtoResponseExcludedInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponseExcludedInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponseExcludedInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponseExcludedInboundsItem) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponseExcludedInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponseExcludedInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponseExcludedInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.ExpiredUsersRemarks != nil {
			e.FieldStart("expiredUsersRemarks")
			e.ArrStart()
			for _, elem := range s.ExpiredUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LimitedUsersRemarks != nil {
			e.FieldStart("limitedUsersRemarks")
			e.ArrStart()
			for _, elem := range s.LimitedUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisabledUsersRemarks != nil {
			e.FieldStart("disabledUsersRemarks")
			e.ArrStart()
			for _, elem := range s.DisabledUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CustomResponseHeaders.Set {
			e.FieldStart("customResponseHeaders")
			s.CustomResponseHeaders.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto = [14]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
}

// Decode decodes UpdateSubscriptionSettingsRequestDto from json.
func (s *UpdateSubscriptionSettingsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			if err := func() error {
				s.CustomResponseHeaders.Reset()
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders from json.
func (s *UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateSubscriptionSettingsResponseDto from json.
func (s *UpdateSubscriptionSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileTitle")
		e.Str(s.ProfileTitle)
	}
	{
		e.FieldStart("supportLink")
		e.Str(s.SupportLink)
	}
	{
		e.FieldStart("profileUpdateInterval")
		e.Int(s.ProfileUpdateInterval)
	}
	{
		e.FieldStart("isProfileWebpageUrlEnabled")
		e.Bool(s.IsProfileWebpageUrlEnabled)
	}
	{
		e.FieldStart("serveJsonAtBaseSubscription")
		e.Bool(s.ServeJsonAtBaseSubscription)
	}
	{
		e.FieldStart("addUsernameToBaseSubscription")
		e.Bool(s.AddUsernameToBaseSubscription)
	}
	{
		e.FieldStart("isShowCustomRemarks")
		e.Bool(s.IsShowCustomRemarks)
	}
	{
		e.FieldStart("happAnnounce")
		s.HappAnnounce.Encode(e)
	}
	{
		e.FieldStart("happRouting")
		s.HappRouting.Encode(e)
	}
	{
		e.FieldStart("expiredUsersRemarks")
		e.ArrStart()
		for _, elem := range s.ExpiredUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("limitedUsersRemarks")
		e.ArrStart()
		for _, elem := range s.LimitedUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("disabledUsersRemarks")
		e.ArrStart()
		for _, elem := range s.DisabledUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("customResponseHeaders")
		s.CustomResponseHeaders.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse = [16]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "createdAt",
	15: "updatedAt",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponse from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProfileTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SupportLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProfileUpdateInterval = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsProfileWebpageUrlEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ServeJsonAtBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AddUsernameToBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsShowCustomRemarks = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "createdAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if s.TemplateJson != nil {
			e.FieldStart("templateJson")
			s.TemplateJson.Encode(e)
		}
	}
	{
		if s.EncodedTemplateYaml.Set {
			e.FieldStart("encodedTemplateYaml")
			s.EncodedTemplateYaml.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTemplateRequestDto = [3]string{
	0: "templateType",
	1: "templateJson",
	2: "encodedTemplateYaml",
}

// Decode decodes UpdateTemplateRequestDto from json.
func (s *UpdateTemplateRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templateType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			if err := func() error {
				s.TemplateJson = nil
				var elem UpdateTemplateRequestDtoTemplateJson
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TemplateJson = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			if err := func() error {
				s.EncodedTemplateYaml.Reset()
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateRequestDto) {
					name = jsonFieldsNameOfUpdateTemplateRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequestDtoTemplateJson) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateTemplateRequestDtoTemplateJson = [0]string{}

// Decode decodes UpdateTemplateRequestDtoTemplateJson from json.
func (s *UpdateTemplateRequestDtoTemplateJson) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDtoTemplateJson to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequestDtoTemplateJson")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTemplateRequestDtoTemplateType as json.
func (s UpdateTemplateRequestDtoTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTemplateRequestDtoTemplateType from json.
func (s *UpdateTemplateRequestDtoTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDtoTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTemplateRequestDtoTemplateType(v) {
	case UpdateTemplateRequestDtoTemplateTypeSTASH:
		*s = UpdateTemplateRequestDtoTemplateTypeSTASH
	case UpdateTemplateRequestDtoTemplateTypeSINGBOX:
		*s = UpdateTemplateRequestDtoTemplateTypeSINGBOX
	case UpdateTemplateRequestDtoTemplateTypeSINGBOXLEGACY:
		*s = UpdateTemplateRequestDtoTemplateTypeSINGBOXLEGACY
	case UpdateTemplateRequestDtoTemplateTypeMIHOMO:
		*s = UpdateTemplateRequestDtoTemplateTypeMIHOMO
	case UpdateTemplateRequestDtoTemplateTypeXRAYJSON:
		*s = UpdateTemplateRequestDtoTemplateTypeXRAYJSON
	case UpdateTemplateRequestDtoTemplateTypeCLASH:
		*s = UpdateTemplateRequestDtoTemplateTypeCLASH
	default:
		*s = UpdateTemplateRequestDtoTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTemplateRequestDtoTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDtoTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateTemplateResponseDto from json.
func (s *UpdateTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateResponseDto) {
					name = jsonFieldsNameOfUpdateTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfUpdateTemplateResponseDtoResponse = [4]string{
	0: "uuid",
	1: "templateType",
	2: "templateJson",
	3: "encodedTemplateYaml",
}

// Decode decodes UpdateTemplateResponseDtoResponse from json.
func (s *UpdateTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTemplateResponseDtoResponseTemplateType as json.
func (s UpdateTemplateResponseDtoResponseTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTemplateResponseDtoResponseTemplateType from json.
func (s *UpdateTemplateResponseDtoResponseTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDtoResponseTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTemplateResponseDtoResponseTemplateType(v) {
	case UpdateTemplateResponseDtoResponseTemplateTypeSTASH:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSTASH
	case UpdateTemplateResponseDtoResponseTemplateTypeSINGBOX:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSINGBOX
	case UpdateTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY
	case UpdateTemplateResponseDtoResponseTemplateTypeMIHOMO:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeMIHOMO
	case UpdateTemplateResponseDtoResponseTemplateTypeXRAYJSON:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeXRAYJSON
	case UpdateTemplateResponseDtoResponseTemplateTypeCLASH:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeCLASH
	default:
		*s = UpdateTemplateResponseDtoResponseTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTemplateResponseDtoResponseTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDtoResponseTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ActiveUserInbounds != nil {
			e.FieldStart("activeUserInbounds")
			e.ArrStart()
			for _, elem := range s.ActiveUserInbounds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateUserRequestDto = [11]string{
	0:  "uuid",
	1:  "status",
	2:  "trafficLimitBytes",
	3:  "trafficLimitStrategy",
	4:  "activeUserInbounds",
	5:  "expireAt",
	6:  "description",
	7:  "tag",
	8:  "telegramId",
	9:  "email",
	10: "hwidDeviceLimit",
}

// Decode decodes UpdateUserRequestDto from json.
func (s *UpdateUserRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "activeUserInbounds":
			if err := func() error {
				s.ActiveUserInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUserRequestDto) {
					name = jsonFieldsNameOfUpdateUserRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoStatus as json.
func (s UpdateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserRequestDtoStatus from json.
func (s *UpdateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserRequestDtoStatus(v) {
	case UpdateUserRequestDtoStatusACTIVE:
		*s = UpdateUserRequestDtoStatusACTIVE
	case UpdateUserRequestDtoStatusDISABLED:
		*s = UpdateUserRequestDtoStatusDISABLED
	case UpdateUserRequestDtoStatusLIMITED:
		*s = UpdateUserRequestDtoStatusLIMITED
	case UpdateUserRequestDtoStatusEXPIRED:
		*s = UpdateUserRequestDtoStatusEXPIRED
	default:
		*s = UpdateUserRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoTrafficLimitStrategy as json.
func (s UpdateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserRequestDtoTrafficLimitStrategy from json.
func (s *UpdateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserRequestDtoTrafficLimitStrategy(v) {
	case UpdateUserRequestDtoTrafficLimitStrategyNORESET:
		*s = UpdateUserRequestDtoTrafficLimitStrategyNORESET
	case UpdateUserRequestDtoTrafficLimitStrategyDAY:
		*s = UpdateUserRequestDtoTrafficLimitStrategyDAY
	case UpdateUserRequestDtoTrafficLimitStrategyWEEK:
		*s = UpdateUserRequestDtoTrafficLimitStrategyWEEK
	case UpdateUserRequestDtoTrafficLimitStrategyMONTH:
		*s = UpdateUserRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = UpdateUserRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeUserInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveUserInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfUserDto = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeUserInbounds",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes UserDto from json.
func (s *UserDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDto to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeUserInbounds":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveUserInbounds = make([]UserDtoActiveUserInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserDtoActiveUserInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUserInbounds = append(s.ActiveUserInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUserInbounds\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11110111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDto) {
					name = jsonFieldsNameOfUserDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDtoActiveUserInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDtoActiveUserInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
}

var jsonFieldsNameOfUserDtoActiveUserInboundsItem = [5]string{
	0: "uuid",
	1: "tag",
	2: "type",
	3: "network",
	4: "security",
}

// Decode decodes UserDtoActiveUserInboundsItem from json.
func (s *UserDtoActiveUserInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoActiveUserInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDtoActiveUserInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDtoActiveUserInboundsItem) {
					name = jsonFieldsNameOfUserDtoActiveUserInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDtoActiveUserInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoActiveUserInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDtoHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDtoHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfUserDtoHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes UserDtoHapp from json.
func (s *UserDtoHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDtoHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDtoHapp) {
					name = jsonFieldsNameOfUserDtoHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDtoHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDtoLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDtoLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfUserDtoLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes UserDtoLastConnectedNode from json.
func (s *UserDtoLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDtoLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDtoLastConnectedNode) {
					name = jsonFieldsNameOfUserDtoLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDtoLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoStatus as json.
func (s UserDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserDtoStatus from json.
func (s *UserDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserDtoStatus(v) {
	case UserDtoStatusACTIVE:
		*s = UserDtoStatusACTIVE
	case UserDtoStatusDISABLED:
		*s = UserDtoStatusDISABLED
	case UserDtoStatusLIMITED:
		*s = UserDtoStatusLIMITED
	case UserDtoStatusEXPIRED:
		*s = UserDtoStatusEXPIRED
	default:
		*s = UserDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoTrafficLimitStrategy as json.
func (s UserDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserDtoTrafficLimitStrategy from json.
func (s *UserDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserDtoTrafficLimitStrategy(v) {
	case UserDtoTrafficLimitStrategyNORESET:
		*s = UserDtoTrafficLimitStrategyNORESET
	case UserDtoTrafficLimitStrategyDAY:
		*s = UserDtoTrafficLimitStrategyDAY
	case UserDtoTrafficLimitStrategyWEEK:
		*s = UserDtoTrafficLimitStrategyWEEK
	case UserDtoTrafficLimitStrategyMONTH:
		*s = UserDtoTrafficLimitStrategyMONTH
	default:
		*s = UserDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes UserResponseDto from json.
func (s *UserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserResponseDto) {
					name = jsonFieldsNameOfUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUsersDto = [1]string{
	0: "response",
}

// Decode decodes UsersDto from json.
func (s *UsersDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]UserDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersDto) {
					name = jsonFieldsNameOfUsersDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
