// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

type requestConfig struct {
	Client       ht.Client
	ServerURL    *url.URL
	EditRequest  func(req *http.Request) error
	EditResponse func(resp *http.Response) error
}

func (cfg *requestConfig) setDefaults(c baseClient) {
	if cfg.Client == nil {
		cfg.Client = c.cfg.Client
	}
}

func (cfg *requestConfig) onRequest(req *http.Request) error {
	if fn := cfg.EditRequest; fn != nil {
		return fn(req)
	}
	return nil
}

func (cfg *requestConfig) onResponse(resp *http.Response) error {
	if fn := cfg.EditResponse; fn != nil {
		return fn(resp)
	}
	return nil
}

// RequestOption defines options for request.
type RequestOption func(cfg *requestConfig)

// WithRequestClient sets client for request.
func WithRequestClient(client ht.Client) RequestOption {
	return func(cfg *requestConfig) {
		cfg.Client = client
	}
}

// WithServerURL sets client for request.
func WithServerURL(u *url.URL) RequestOption {
	return func(cfg *requestConfig) {
		cfg.ServerURL = u
	}
}

// WithEditRequest sets function to edit request.
func WithEditRequest(fn func(req *http.Request) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditRequest = fn
	}
}

// WithEditResponse sets function to edit response.
func WithEditResponse(fn func(resp *http.Response) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditResponse = fn
	}
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ApiTokensControllerCreate invokes ApiTokensController_create operation.
	//
	// This endpoint is forbidden to use via "API-key". It can only be used with an admin JWT-token.
	//
	// POST /api/tokens
	ApiTokensControllerCreate(ctx context.Context, request *CreateApiTokenRequestDto, options ...RequestOption) (*CreateApiTokenResponseDto, error)
	// ApiTokensControllerDelete invokes ApiTokensController_delete operation.
	//
	// This endpoint is forbidden to use via "API-key". It can be used only with an admin JWT-token.
	//
	// DELETE /api/tokens/{uuid}
	ApiTokensControllerDelete(ctx context.Context, params ApiTokensControllerDeleteParams, options ...RequestOption) (*DeleteApiTokenResponseDto, error)
	// ApiTokensControllerFindAll invokes ApiTokensController_findAll operation.
	//
	// This endpoint is forbidden to use via "API-key". It can only be used with admin JWT-token.
	//
	// GET /api/tokens
	ApiTokensControllerFindAll(ctx context.Context, options ...RequestOption) (*FindAllApiTokensResponseDto, error)
	// AuthControllerGetStatus invokes AuthController_getStatus operation.
	//
	// Get the status of the authentication.
	//
	// GET /api/auth/status
	AuthControllerGetStatus(ctx context.Context, options ...RequestOption) (*GetStatusResponseDtoStatusCode, error)
	// AuthControllerLogin invokes AuthController_login operation.
	//
	// Login as superadmin.
	//
	// POST /api/auth/login
	AuthControllerLogin(ctx context.Context, request *LoginRequestDto, options ...RequestOption) (AuthControllerLoginRes, error)
	// AuthControllerRegister invokes AuthController_register operation.
	//
	// Register as superadmin.
	//
	// POST /api/auth/register
	AuthControllerRegister(ctx context.Context, request *RegisterRequestDto, options ...RequestOption) (AuthControllerRegisterRes, error)
	// AuthControllerTelegramCallback invokes AuthController_telegramCallback operation.
	//
	// Callback from Telegram OAuth2.
	//
	// POST /api/auth/oauth2/tg/callback
	AuthControllerTelegramCallback(ctx context.Context, request *TelegramCallbackRequestDto, options ...RequestOption) (*TelegramCallbackResponseDtoStatusCode, error)
	// HostsBulkActionsControllerDeleteHosts invokes HostsBulkActionsController_deleteHosts operation.
	//
	// Delete hosts by UUIDs.
	//
	// POST /api/hosts/bulk/delete
	HostsBulkActionsControllerDeleteHosts(ctx context.Context, request *BulkDeleteHostsRequestDto, options ...RequestOption) (*BulkDeleteHostsResponseDto, error)
	// HostsBulkActionsControllerDisableHosts invokes HostsBulkActionsController_disableHosts operation.
	//
	// Disable hosts by UUIDs.
	//
	// POST /api/hosts/bulk/disable
	HostsBulkActionsControllerDisableHosts(ctx context.Context, request *BulkDisableHostsRequestDto, options ...RequestOption) (*BulkDisableHostsResponseDto, error)
	// HostsBulkActionsControllerEnableHosts invokes HostsBulkActionsController_enableHosts operation.
	//
	// Enable hosts by UUIDs.
	//
	// POST /api/hosts/bulk/enable
	HostsBulkActionsControllerEnableHosts(ctx context.Context, request *BulkEnableHostsRequestDto, options ...RequestOption) (*BulkEnableHostsResponseDto, error)
	// HostsBulkActionsControllerSetInboundToHosts invokes HostsBulkActionsController_setInboundToHosts operation.
	//
	// Set inbound to hosts by UUIDs.
	//
	// POST /api/hosts/bulk/set-inbound
	HostsBulkActionsControllerSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequestDto, options ...RequestOption) (*SetInboundToManyHostsResponseDto, error)
	// HostsBulkActionsControllerSetPortToHosts invokes HostsBulkActionsController_setPortToHosts operation.
	//
	// Set port to hosts by UUIDs.
	//
	// POST /api/hosts/bulk/set-port
	HostsBulkActionsControllerSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequestDto, options ...RequestOption) (*SetPortToManyHostsResponseDto, error)
	// HostsControllerCreateHost invokes HostsController_createHost operation.
	//
	// Create a new host.
	//
	// POST /api/hosts
	HostsControllerCreateHost(ctx context.Context, request *CreateHostRequestDto, options ...RequestOption) (*CreateHostResponseDto, error)
	// HostsControllerDeleteHost invokes HostsController_deleteHost operation.
	//
	// Delete a host by UUID.
	//
	// DELETE /api/hosts/{uuid}
	HostsControllerDeleteHost(ctx context.Context, params HostsControllerDeleteHostParams, options ...RequestOption) (HostsControllerDeleteHostRes, error)
	// HostsControllerGetAllHosts invokes HostsController_getAllHosts operation.
	//
	// Get all hosts.
	//
	// GET /api/hosts
	HostsControllerGetAllHosts(ctx context.Context, options ...RequestOption) (*GetAllHostsResponseDto, error)
	// HostsControllerGetOneHost invokes HostsController_getOneHost operation.
	//
	// Get a host by UUID.
	//
	// GET /api/hosts/{uuid}
	HostsControllerGetOneHost(ctx context.Context, params HostsControllerGetOneHostParams, options ...RequestOption) (*GetOneHostResponseDto, error)
	// HostsControllerReorderHosts invokes HostsController_reorderHosts operation.
	//
	// Reorder hosts.
	//
	// POST /api/hosts/actions/reorder
	HostsControllerReorderHosts(ctx context.Context, request *ReorderHostRequestDto, options ...RequestOption) (*ReorderHostResponseDto, error)
	// HostsControllerUpdateHost invokes HostsController_updateHost operation.
	//
	// Update a host.
	//
	// PATCH /api/hosts
	HostsControllerUpdateHost(ctx context.Context, request *UpdateHostRequestDto, options ...RequestOption) (*UpdateHostResponseDto, error)
	// HwidUserDevicesControllerCreateUserHwidDevice invokes HwidUserDevicesController_createUserHwidDevice operation.
	//
	// Create a user HWID device.
	//
	// POST /api/hwid/devices
	HwidUserDevicesControllerCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequestDto, options ...RequestOption) (*CreateUserHwidDeviceResponseDto, error)
	// HwidUserDevicesControllerDeleteUserHwidDevice invokes HwidUserDevicesController_deleteUserHwidDevice operation.
	//
	// Delete a user HWID device.
	//
	// POST /api/hwid/devices/delete
	HwidUserDevicesControllerDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequestDto, options ...RequestOption) (*DeleteUserHwidDeviceResponseDto, error)
	// HwidUserDevicesControllerGetUserHwidDevices invokes HwidUserDevicesController_getUserHwidDevices operation.
	//
	// Get user HWID devices.
	//
	// GET /api/hwid/devices/{userUuid}
	HwidUserDevicesControllerGetUserHwidDevices(ctx context.Context, params HwidUserDevicesControllerGetUserHwidDevicesParams, options ...RequestOption) (*GetUserHwidDevicesResponseDto, error)
	// InboundsBulkActionsControllerAddInboundToNodes invokes InboundsBulkActionsController_addInboundToNodes operation.
	//
	// Add inbound to nodes.
	//
	// POST /api/inbounds/bulk/add-to-nodes
	InboundsBulkActionsControllerAddInboundToNodes(ctx context.Context, request *AddInboundToNodesRequestDto, options ...RequestOption) (*AddInboundToNodesResponseDto, error)
	// InboundsBulkActionsControllerAddInboundToUsers invokes InboundsBulkActionsController_addInboundToUsers operation.
	//
	// Add inbound to users.
	//
	// POST /api/inbounds/bulk/add-to-users
	InboundsBulkActionsControllerAddInboundToUsers(ctx context.Context, request *AddInboundToUsersRequestDto, options ...RequestOption) (*AddInboundToUsersResponseDto, error)
	// InboundsBulkActionsControllerRemoveInboundFromNodes invokes InboundsBulkActionsController_removeInboundFromNodes operation.
	//
	// Remove inbound from nodes.
	//
	// POST /api/inbounds/bulk/remove-from-nodes
	InboundsBulkActionsControllerRemoveInboundFromNodes(ctx context.Context, request *RemoveInboundFromNodesRequestDto, options ...RequestOption) (*RemoveInboundFromNodesResponseDto, error)
	// InboundsBulkActionsControllerRemoveInboundFromUsers invokes InboundsBulkActionsController_removeInboundFromUsers operation.
	//
	// Remove inbound from users.
	//
	// POST /api/inbounds/bulk/remove-from-users
	InboundsBulkActionsControllerRemoveInboundFromUsers(ctx context.Context, request *RemoveInboundFromUsersRequestDto, options ...RequestOption) (*RemoveInboundFromUsersResponseDto, error)
	// InboundsControllerGetFullInbounds invokes InboundsController_getFullInbounds operation.
	//
	// Get inbounds with full details.
	//
	// GET /api/inbounds/full
	InboundsControllerGetFullInbounds(ctx context.Context, options ...RequestOption) (*GetFullInboundsResponseDto, error)
	// InboundsControllerGetInbounds invokes InboundsController_getInbounds operation.
	//
	// Get inbounds.
	//
	// GET /api/inbounds
	InboundsControllerGetInbounds(ctx context.Context, options ...RequestOption) (*GetInboundsResponseDto, error)
	// KeygenControllerGenerateKey invokes KeygenController_generateKey operation.
	//
	// Get SSL_CERT for Aura Node.
	//
	// GET /api/keygen
	KeygenControllerGenerateKey(ctx context.Context, options ...RequestOption) (*GetPubKeyResponseDto, error)
	// NodesControllerCreateNode invokes NodesController_createNode operation.
	//
	// Create a new node.
	//
	// POST /api/nodes
	NodesControllerCreateNode(ctx context.Context, request *CreateNodeRequestDto, options ...RequestOption) (*CreateNodeResponseDto, error)
	// NodesControllerDeleteNode invokes NodesController_deleteNode operation.
	//
	// Delete a node.
	//
	// DELETE /api/nodes/{uuid}
	NodesControllerDeleteNode(ctx context.Context, params NodesControllerDeleteNodeParams, options ...RequestOption) (*DeleteNodeResponseDto, error)
	// NodesControllerDisableNode invokes NodesController_disableNode operation.
	//
	// Disable a node.
	//
	// POST /api/nodes/{uuid}/actions/disable
	NodesControllerDisableNode(ctx context.Context, params NodesControllerDisableNodeParams, options ...RequestOption) (*DisableNodeResponseDto, error)
	// NodesControllerEnableNode invokes NodesController_enableNode operation.
	//
	// Enable a node.
	//
	// POST /api/nodes/{uuid}/actions/enable
	NodesControllerEnableNode(ctx context.Context, params NodesControllerEnableNodeParams, options ...RequestOption) (*EnableNodeResponseDto, error)
	// NodesControllerGetAllNodes invokes NodesController_getAllNodes operation.
	//
	// Get all nodes.
	//
	// GET /api/nodes
	NodesControllerGetAllNodes(ctx context.Context, options ...RequestOption) (*GetAllNodesResponseDto, error)
	// NodesControllerGetOneNode invokes NodesController_getOneNode operation.
	//
	// Get node by UUID.
	//
	// GET /api/nodes/{uuid}
	NodesControllerGetOneNode(ctx context.Context, params NodesControllerGetOneNodeParams, options ...RequestOption) (*GetOneNodeResponseDto, error)
	// NodesControllerReorderNodes invokes NodesController_reorderNodes operation.
	//
	// Reorder nodes.
	//
	// POST /api/nodes/actions/reorder
	NodesControllerReorderNodes(ctx context.Context, request *ReorderNodeRequestDto, options ...RequestOption) (*ReorderNodeResponseDto, error)
	// NodesControllerRestartAllNodes invokes NodesController_restartAllNodes operation.
	//
	// Restart all nodes.
	//
	// POST /api/nodes/actions/restart-all
	NodesControllerRestartAllNodes(ctx context.Context, options ...RequestOption) (*RestartAllNodesResponseDto, error)
	// NodesControllerRestartNode invokes NodesController_restartNode operation.
	//
	// Restart node.
	//
	// POST /api/nodes/{uuid}/actions/restart
	NodesControllerRestartNode(ctx context.Context, params NodesControllerRestartNodeParams, options ...RequestOption) (*RestartNodeResponseDto, error)
	// NodesControllerUpdateNode invokes NodesController_updateNode operation.
	//
	// Update node.
	//
	// PATCH /api/nodes
	NodesControllerUpdateNode(ctx context.Context, request *UpdateNodeRequestDto, options ...RequestOption) (*UpdateNodeResponseDto, error)
	// NodesUsageHistoryControllerGetNodesUsageByRange invokes NodesUsageHistoryController_getNodesUsageByRange operation.
	//
	// Get nodes usage by range.
	//
	// GET /api/nodes/usage/range
	NodesUsageHistoryControllerGetNodesUsageByRange(ctx context.Context, params NodesUsageHistoryControllerGetNodesUsageByRangeParams, options ...RequestOption) (*GetNodesUsageByRangeResponseDto, error)
	// NodesUserUsageHistoryControllerGetNodeUserUsage invokes NodesUserUsageHistoryController_getNodeUserUsage operation.
	//
	// Get node user usage by range and Node UUID.
	//
	// GET /api/nodes/usage/{uuid}/users/range
	NodesUserUsageHistoryControllerGetNodeUserUsage(ctx context.Context, params NodesUserUsageHistoryControllerGetNodeUserUsageParams, options ...RequestOption) (*GetNodeUserUsageByRangeResponseDto, error)
	// NodesUserUsageHistoryControllerGetNodesRealtimeUsage invokes NodesUserUsageHistoryController_getNodesRealtimeUsage operation.
	//
	// Get nodes realtime usage.
	//
	// GET /api/nodes/usage/realtime
	NodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx context.Context, options ...RequestOption) (*GetNodesRealtimeUsageResponseDto, error)
	// SubscriptionControllerGetSubscription invokes SubscriptionController_getSubscription operation.
	//
	// GET /api/sub/{shortUuid}
	SubscriptionControllerGetSubscription(ctx context.Context, params SubscriptionControllerGetSubscriptionParams, options ...RequestOption) error
	// SubscriptionControllerGetSubscriptionByClientType invokes SubscriptionController_getSubscriptionByClientType operation.
	//
	// GET /api/sub/{shortUuid}/{clientType}
	SubscriptionControllerGetSubscriptionByClientType(ctx context.Context, params SubscriptionControllerGetSubscriptionByClientTypeParams, options ...RequestOption) error
	// SubscriptionControllerGetSubscriptionInfoByShortUuid invokes SubscriptionController_getSubscriptionInfoByShortUuid operation.
	//
	// Get Subscription Info by Short UUID.
	//
	// GET /api/sub/{shortUuid}/info
	SubscriptionControllerGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionControllerGetSubscriptionInfoByShortUuidParams, options ...RequestOption) (*GetSubscriptionInfoResponseDto, error)
	// SubscriptionControllerGetSubscriptionWithType invokes SubscriptionController_getSubscriptionWithType operation.
	//
	// GET /api/sub/outline/{shortUuid}/{type}/{encodedTag}
	SubscriptionControllerGetSubscriptionWithType(ctx context.Context, params SubscriptionControllerGetSubscriptionWithTypeParams, options ...RequestOption) error
	// SubscriptionSettingsControllerGetSettings invokes SubscriptionSettingsController_getSettings operation.
	//
	// Get subscription settings.
	//
	// GET /api/subscription-settings
	SubscriptionSettingsControllerGetSettings(ctx context.Context, options ...RequestOption) (*GetSubscriptionSettingsResponseDto, error)
	// SubscriptionSettingsControllerUpdateSettings invokes SubscriptionSettingsController_updateSettings operation.
	//
	// Update subscription settings.
	//
	// PATCH /api/subscription-settings
	SubscriptionSettingsControllerUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequestDto, options ...RequestOption) (*UpdateSubscriptionSettingsResponseDto, error)
	// SubscriptionTemplateControllerGetTemplate invokes SubscriptionTemplateController_getTemplate operation.
	//
	// Get subscription template.
	//
	// GET /api/subscription-templates/{templateType}
	SubscriptionTemplateControllerGetTemplate(ctx context.Context, params SubscriptionTemplateControllerGetTemplateParams, options ...RequestOption) (*GetTemplateResponseDto, error)
	// SubscriptionTemplateControllerUpdateTemplate invokes SubscriptionTemplateController_updateTemplate operation.
	//
	// Update subscription template.
	//
	// PUT /api/subscription-templates
	SubscriptionTemplateControllerUpdateTemplate(ctx context.Context, request *UpdateTemplateRequestDto, options ...RequestOption) (*UpdateTemplateResponseDto, error)
	// SubscriptionsControllerGetAllSubscriptions invokes SubscriptionsController_getAllSubscriptions operation.
	//
	// Get all subscriptions.
	//
	// GET /api/subscriptions
	SubscriptionsControllerGetAllSubscriptions(ctx context.Context, params SubscriptionsControllerGetAllSubscriptionsParams, options ...RequestOption) (*GetAllSubscriptionsResponseDto, error)
	// SubscriptionsControllerGetSubscriptionByUsername invokes SubscriptionsController_getSubscriptionByUsername operation.
	//
	// Get subscription by username.
	//
	// GET /api/subscriptions/by-username/{username}
	SubscriptionsControllerGetSubscriptionByUsername(ctx context.Context, params SubscriptionsControllerGetSubscriptionByUsernameParams, options ...RequestOption) (SubscriptionsControllerGetSubscriptionByUsernameRes, error)
	// SystemControllerGetBandwidthStats invokes SystemController_getBandwidthStats operation.
	//
	// Get Bandwidth Stats.
	//
	// GET /api/system/stats/bandwidth
	SystemControllerGetBandwidthStats(ctx context.Context, options ...RequestOption) (*GetBandwidthStatsResponseDto, error)
	// SystemControllerGetNodesStatistics invokes SystemController_getNodesStatistics operation.
	//
	// Get Nodes Statistics.
	//
	// GET /api/system/stats/nodes
	SystemControllerGetNodesStatistics(ctx context.Context, options ...RequestOption) (*GetNodesStatisticsResponseDto, error)
	// SystemControllerGetStats invokes SystemController_getStats operation.
	//
	// Get Stats.
	//
	// GET /api/system/stats
	SystemControllerGetStats(ctx context.Context, options ...RequestOption) (*GetStatsResponseDto, error)
	// UsersBulkActionsControllerBulkAllResetUserTraffic invokes UsersBulkActionsController_bulkAllResetUserTraffic operation.
	//
	// Bulk reset all users traffic.
	//
	// POST /api/users/bulk/all/reset-traffic
	UsersBulkActionsControllerBulkAllResetUserTraffic(ctx context.Context, options ...RequestOption) (*BulkAllResetTrafficUsersResponseDto, error)
	// UsersBulkActionsControllerBulkDeleteUsers invokes UsersBulkActionsController_bulkDeleteUsers operation.
	//
	// Bulk delete users by UUIDs.
	//
	// POST /api/users/bulk/delete
	UsersBulkActionsControllerBulkDeleteUsers(ctx context.Context, request *BulkDeleteUsersRequestDto, options ...RequestOption) (*BulkDeleteUsersResponseDto, error)
	// UsersBulkActionsControllerBulkDeleteUsersByStatus invokes UsersBulkActionsController_bulkDeleteUsersByStatus operation.
	//
	// Bulk delete users by status.
	//
	// POST /api/users/bulk/delete-by-status
	UsersBulkActionsControllerBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequestDto, options ...RequestOption) (*BulkDeleteUsersByStatusResponseDto, error)
	// UsersBulkActionsControllerBulkResetUserTraffic invokes UsersBulkActionsController_bulkResetUserTraffic operation.
	//
	// Bulk reset traffic users by UUIDs.
	//
	// POST /api/users/bulk/reset-traffic
	UsersBulkActionsControllerBulkResetUserTraffic(ctx context.Context, request *BulkResetTrafficUsersRequestDto, options ...RequestOption) (*BulkResetTrafficUsersResponseDto, error)
	// UsersBulkActionsControllerBulkRevokeUsersSubscription invokes UsersBulkActionsController_bulkRevokeUsersSubscription operation.
	//
	// Revoke users subscription by User UUIDs.
	//
	// POST /api/users/bulk/revoke-subscription
	UsersBulkActionsControllerBulkRevokeUsersSubscription(ctx context.Context, request *BulkRevokeUsersSubscriptionRequestDto, options ...RequestOption) (*BulkRevokeUsersSubscriptionResponseDto, error)
	// UsersBulkActionsControllerBulkUpdateAllUsers invokes UsersBulkActionsController_bulkUpdateAllUsers operation.
	//
	// Bulk update all users.
	//
	// POST /api/users/bulk/all/update
	UsersBulkActionsControllerBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequestDto, options ...RequestOption) (*BulkAllUpdateUsersResponseDto, error)
	// UsersBulkActionsControllerBulkUpdateUsers invokes UsersBulkActionsController_bulkUpdateUsers operation.
	//
	// Bulk update users by UUIDs.
	//
	// POST /api/users/bulk/update
	UsersBulkActionsControllerBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequestDto, options ...RequestOption) (*BulkUpdateUsersResponseDto, error)
	// UsersBulkActionsControllerBulkUpdateUsersInbounds invokes UsersBulkActionsController_bulkUpdateUsersInbounds operation.
	//
	// Bulk update users inbounds by UUIDs.
	//
	// POST /api/users/bulk/update-inbounds
	UsersBulkActionsControllerBulkUpdateUsersInbounds(ctx context.Context, request *BulkUpdateUsersInboundsRequestDto, options ...RequestOption) (*BulkUpdateUsersInboundsResponseDto, error)
	// UsersControllerActivateAllInbounds invokes UsersController_activateAllInbounds operation.
	//
	// Activate all inbounds.
	//
	// POST /api/users/{uuid}/actions/activate-all-inbounds
	UsersControllerActivateAllInbounds(ctx context.Context, params UsersControllerActivateAllInboundsParams, options ...RequestOption) (UsersControllerActivateAllInboundsRes, error)
	// UsersControllerCreateUser invokes UsersController_createUser operation.
	//
	// Create a new user.
	//
	// POST /api/users
	UsersControllerCreateUser(ctx context.Context, request *CreateUserRequestDto, options ...RequestOption) (*UserResponseDto, error)
	// UsersControllerDeleteUser invokes UsersController_deleteUser operation.
	//
	// Delete user.
	//
	// DELETE /api/users/{uuid}
	UsersControllerDeleteUser(ctx context.Context, params UsersControllerDeleteUserParams, options ...RequestOption) (UsersControllerDeleteUserRes, error)
	// UsersControllerDisableUser invokes UsersController_disableUser operation.
	//
	// Disable user.
	//
	// POST /api/users/{uuid}/actions/disable
	UsersControllerDisableUser(ctx context.Context, params UsersControllerDisableUserParams, options ...RequestOption) (UsersControllerDisableUserRes, error)
	// UsersControllerEnableUser invokes UsersController_enableUser operation.
	//
	// Enable user.
	//
	// POST /api/users/{uuid}/actions/enable
	UsersControllerEnableUser(ctx context.Context, params UsersControllerEnableUserParams, options ...RequestOption) (UsersControllerEnableUserRes, error)
	// UsersControllerGetAllTags invokes UsersController_getAllTags operation.
	//
	// Get all existing user tags.
	//
	// GET /api/users/tags
	UsersControllerGetAllTags(ctx context.Context, options ...RequestOption) (*GetAllTagsResponseDto, error)
	// UsersControllerGetAllUsers invokes UsersController_getAllUsers operation.
	//
	// Get all users.
	//
	// GET /api/users
	UsersControllerGetAllUsers(ctx context.Context, params UsersControllerGetAllUsersParams, options ...RequestOption) (*GetAllUsersResponseDto, error)
	// UsersControllerGetUserByShortUuid invokes UsersController_getUserByShortUuid operation.
	//
	// Get user by Short UUID.
	//
	// GET /api/users/by-short-uuid/{shortUuid}
	UsersControllerGetUserByShortUuid(ctx context.Context, params UsersControllerGetUserByShortUuidParams, options ...RequestOption) (UsersControllerGetUserByShortUuidRes, error)
	// UsersControllerGetUserBySubscriptionUuid invokes UsersController_getUserBySubscriptionUuid operation.
	//
	// Get user by subscription UUID.
	//
	// GET /api/users/by-subscription-uuid/{subscriptionUuid}
	UsersControllerGetUserBySubscriptionUuid(ctx context.Context, params UsersControllerGetUserBySubscriptionUuidParams, options ...RequestOption) (UsersControllerGetUserBySubscriptionUuidRes, error)
	// UsersControllerGetUserByTelegramId invokes UsersController_getUserByTelegramId operation.
	//
	// Get users by telegram ID.
	//
	// GET /api/users/by-telegram-id/{telegramId}
	UsersControllerGetUserByTelegramId(ctx context.Context, params UsersControllerGetUserByTelegramIdParams, options ...RequestOption) (UsersControllerGetUserByTelegramIdRes, error)
	// UsersControllerGetUserByUsername invokes UsersController_getUserByUsername operation.
	//
	// Get user by username.
	//
	// GET /api/users/by-username/{username}
	UsersControllerGetUserByUsername(ctx context.Context, params UsersControllerGetUserByUsernameParams, options ...RequestOption) (UsersControllerGetUserByUsernameRes, error)
	// UsersControllerGetUserByUuid invokes UsersController_getUserByUuid operation.
	//
	// Get user by UUID.
	//
	// GET /api/users/{uuid}
	UsersControllerGetUserByUuid(ctx context.Context, params UsersControllerGetUserByUuidParams, options ...RequestOption) (UsersControllerGetUserByUuidRes, error)
	// UsersControllerGetUsersByEmail invokes UsersController_getUsersByEmail operation.
	//
	// Get users by email.
	//
	// GET /api/users/by-email/{email}
	UsersControllerGetUsersByEmail(ctx context.Context, params UsersControllerGetUsersByEmailParams, options ...RequestOption) (UsersControllerGetUsersByEmailRes, error)
	// UsersControllerGetUsersByTag invokes UsersController_getUsersByTag operation.
	//
	// Get users by tag.
	//
	// GET /api/users/by-tag/{tag}
	UsersControllerGetUsersByTag(ctx context.Context, params UsersControllerGetUsersByTagParams, options ...RequestOption) (UsersControllerGetUsersByTagRes, error)
	// UsersControllerResetUserTraffic invokes UsersController_resetUserTraffic operation.
	//
	// Reset user traffic.
	//
	// POST /api/users/{uuid}/actions/reset-traffic
	UsersControllerResetUserTraffic(ctx context.Context, params UsersControllerResetUserTrafficParams, options ...RequestOption) (UsersControllerResetUserTrafficRes, error)
	// UsersControllerRevokeUserSubscription invokes UsersController_revokeUserSubscription operation.
	//
	// Revoke user subscription.
	//
	// POST /api/users/{uuid}/actions/revoke
	UsersControllerRevokeUserSubscription(ctx context.Context, params UsersControllerRevokeUserSubscriptionParams, options ...RequestOption) (UsersControllerRevokeUserSubscriptionRes, error)
	// UsersControllerUpdateUser invokes UsersController_updateUser operation.
	//
	// Update a user.
	//
	// PATCH /api/users
	UsersControllerUpdateUser(ctx context.Context, request *UpdateUserRequestDto, options ...RequestOption) (*UserResponseDto, error)
	// UsersStatsControllerGetUserUsageByRange invokes UsersStatsController_getUserUsageByRange operation.
	//
	// Get user usage by range.
	//
	// GET /api/users/stats/usage/{uuid}/range
	UsersStatsControllerGetUserUsageByRange(ctx context.Context, params UsersStatsControllerGetUserUsageByRangeParams, options ...RequestOption) (UsersStatsControllerGetUserUsageByRangeRes, error)
	// XrayConfigControllerGetConfig invokes XrayConfigController_getConfig operation.
	//
	// Get XRay config.
	//
	// GET /api/xray
	XrayConfigControllerGetConfig(ctx context.Context, options ...RequestOption) (XrayConfigControllerGetConfigRes, error)
	// XrayConfigControllerUpdateConfig invokes XrayConfigController_updateConfig operation.
	//
	// Update XRay config.
	//
	// PUT /api/xray
	XrayConfigControllerUpdateConfig(ctx context.Context, request *UpdateConfigRequestDto, options ...RequestOption) (XrayConfigControllerUpdateConfigRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

// ApiTokensControllerCreate invokes ApiTokensController_create operation.
//
// This endpoint is forbidden to use via "API-key". It can only be used with an admin JWT-token.
//
// POST /api/tokens
func (c *Client) ApiTokensControllerCreate(ctx context.Context, request *CreateApiTokenRequestDto, options ...RequestOption) (*CreateApiTokenResponseDto, error) {
	res, err := c.sendApiTokensControllerCreate(ctx, request, options...)
	return res, err
}

func (c *Client) sendApiTokensControllerCreate(ctx context.Context, request *CreateApiTokenRequestDto, requestOptions ...RequestOption) (res *CreateApiTokenResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeApiTokensControllerCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ApiTokensControllerCreateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeApiTokensControllerCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApiTokensControllerDelete invokes ApiTokensController_delete operation.
//
// This endpoint is forbidden to use via "API-key". It can be used only with an admin JWT-token.
//
// DELETE /api/tokens/{uuid}
func (c *Client) ApiTokensControllerDelete(ctx context.Context, params ApiTokensControllerDeleteParams, options ...RequestOption) (*DeleteApiTokenResponseDto, error) {
	res, err := c.sendApiTokensControllerDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendApiTokensControllerDelete(ctx context.Context, params ApiTokensControllerDeleteParams, requestOptions ...RequestOption) (res *DeleteApiTokenResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/tokens/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ApiTokensControllerDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeApiTokensControllerDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApiTokensControllerFindAll invokes ApiTokensController_findAll operation.
//
// This endpoint is forbidden to use via "API-key". It can only be used with admin JWT-token.
//
// GET /api/tokens
func (c *Client) ApiTokensControllerFindAll(ctx context.Context, options ...RequestOption) (*FindAllApiTokensResponseDto, error) {
	res, err := c.sendApiTokensControllerFindAll(ctx, options...)
	return res, err
}

func (c *Client) sendApiTokensControllerFindAll(ctx context.Context, requestOptions ...RequestOption) (res *FindAllApiTokensResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ApiTokensControllerFindAllOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeApiTokensControllerFindAllResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerGetStatus invokes AuthController_getStatus operation.
//
// Get the status of the authentication.
//
// GET /api/auth/status
func (c *Client) AuthControllerGetStatus(ctx context.Context, options ...RequestOption) (*GetStatusResponseDtoStatusCode, error) {
	res, err := c.sendAuthControllerGetStatus(ctx, options...)
	return res, err
}

func (c *Client) sendAuthControllerGetStatus(ctx context.Context, requestOptions ...RequestOption) (res *GetStatusResponseDtoStatusCode, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerGetStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerLogin invokes AuthController_login operation.
//
// Login as superadmin.
//
// POST /api/auth/login
func (c *Client) AuthControllerLogin(ctx context.Context, request *LoginRequestDto, options ...RequestOption) (AuthControllerLoginRes, error) {
	res, err := c.sendAuthControllerLogin(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerLogin(ctx context.Context, request *LoginRequestDto, requestOptions ...RequestOption) (res AuthControllerLoginRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/login"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerRegister invokes AuthController_register operation.
//
// Register as superadmin.
//
// POST /api/auth/register
func (c *Client) AuthControllerRegister(ctx context.Context, request *RegisterRequestDto, options ...RequestOption) (AuthControllerRegisterRes, error) {
	res, err := c.sendAuthControllerRegister(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerRegister(ctx context.Context, request *RegisterRequestDto, requestOptions ...RequestOption) (res AuthControllerRegisterRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/register"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerRegisterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerRegisterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerTelegramCallback invokes AuthController_telegramCallback operation.
//
// Callback from Telegram OAuth2.
//
// POST /api/auth/oauth2/tg/callback
func (c *Client) AuthControllerTelegramCallback(ctx context.Context, request *TelegramCallbackRequestDto, options ...RequestOption) (*TelegramCallbackResponseDtoStatusCode, error) {
	res, err := c.sendAuthControllerTelegramCallback(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerTelegramCallback(ctx context.Context, request *TelegramCallbackRequestDto, requestOptions ...RequestOption) (res *TelegramCallbackResponseDtoStatusCode, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/oauth2/tg/callback"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerTelegramCallbackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerTelegramCallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerDeleteHosts invokes HostsBulkActionsController_deleteHosts operation.
//
// Delete hosts by UUIDs.
//
// POST /api/hosts/bulk/delete
func (c *Client) HostsBulkActionsControllerDeleteHosts(ctx context.Context, request *BulkDeleteHostsRequestDto, options ...RequestOption) (*BulkDeleteHostsResponseDto, error) {
	res, err := c.sendHostsBulkActionsControllerDeleteHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerDeleteHosts(ctx context.Context, request *BulkDeleteHostsRequestDto, requestOptions ...RequestOption) (res *BulkDeleteHostsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerDeleteHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerDeleteHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerDeleteHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerDisableHosts invokes HostsBulkActionsController_disableHosts operation.
//
// Disable hosts by UUIDs.
//
// POST /api/hosts/bulk/disable
func (c *Client) HostsBulkActionsControllerDisableHosts(ctx context.Context, request *BulkDisableHostsRequestDto, options ...RequestOption) (*BulkDisableHostsResponseDto, error) {
	res, err := c.sendHostsBulkActionsControllerDisableHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerDisableHosts(ctx context.Context, request *BulkDisableHostsRequestDto, requestOptions ...RequestOption) (res *BulkDisableHostsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerDisableHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerDisableHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerDisableHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerEnableHosts invokes HostsBulkActionsController_enableHosts operation.
//
// Enable hosts by UUIDs.
//
// POST /api/hosts/bulk/enable
func (c *Client) HostsBulkActionsControllerEnableHosts(ctx context.Context, request *BulkEnableHostsRequestDto, options ...RequestOption) (*BulkEnableHostsResponseDto, error) {
	res, err := c.sendHostsBulkActionsControllerEnableHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerEnableHosts(ctx context.Context, request *BulkEnableHostsRequestDto, requestOptions ...RequestOption) (res *BulkEnableHostsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerEnableHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerEnableHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerEnableHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerSetInboundToHosts invokes HostsBulkActionsController_setInboundToHosts operation.
//
// Set inbound to hosts by UUIDs.
//
// POST /api/hosts/bulk/set-inbound
func (c *Client) HostsBulkActionsControllerSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequestDto, options ...RequestOption) (*SetInboundToManyHostsResponseDto, error) {
	res, err := c.sendHostsBulkActionsControllerSetInboundToHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequestDto, requestOptions ...RequestOption) (res *SetInboundToManyHostsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/set-inbound"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerSetInboundToHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerSetInboundToHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerSetInboundToHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerSetPortToHosts invokes HostsBulkActionsController_setPortToHosts operation.
//
// Set port to hosts by UUIDs.
//
// POST /api/hosts/bulk/set-port
func (c *Client) HostsBulkActionsControllerSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequestDto, options ...RequestOption) (*SetPortToManyHostsResponseDto, error) {
	res, err := c.sendHostsBulkActionsControllerSetPortToHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequestDto, requestOptions ...RequestOption) (res *SetPortToManyHostsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/set-port"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerSetPortToHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerSetPortToHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerSetPortToHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerCreateHost invokes HostsController_createHost operation.
//
// Create a new host.
//
// POST /api/hosts
func (c *Client) HostsControllerCreateHost(ctx context.Context, request *CreateHostRequestDto, options ...RequestOption) (*CreateHostResponseDto, error) {
	res, err := c.sendHostsControllerCreateHost(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsControllerCreateHost(ctx context.Context, request *CreateHostRequestDto, requestOptions ...RequestOption) (res *CreateHostResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsControllerCreateHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerCreateHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerCreateHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerDeleteHost invokes HostsController_deleteHost operation.
//
// Delete a host by UUID.
//
// DELETE /api/hosts/{uuid}
func (c *Client) HostsControllerDeleteHost(ctx context.Context, params HostsControllerDeleteHostParams, options ...RequestOption) (HostsControllerDeleteHostRes, error) {
	res, err := c.sendHostsControllerDeleteHost(ctx, params, options...)
	return res, err
}

func (c *Client) sendHostsControllerDeleteHost(ctx context.Context, params HostsControllerDeleteHostParams, requestOptions ...RequestOption) (res HostsControllerDeleteHostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hosts/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerDeleteHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerDeleteHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerGetAllHosts invokes HostsController_getAllHosts operation.
//
// Get all hosts.
//
// GET /api/hosts
func (c *Client) HostsControllerGetAllHosts(ctx context.Context, options ...RequestOption) (*GetAllHostsResponseDto, error) {
	res, err := c.sendHostsControllerGetAllHosts(ctx, options...)
	return res, err
}

func (c *Client) sendHostsControllerGetAllHosts(ctx context.Context, requestOptions ...RequestOption) (res *GetAllHostsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerGetAllHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerGetAllHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerGetOneHost invokes HostsController_getOneHost operation.
//
// Get a host by UUID.
//
// GET /api/hosts/{uuid}
func (c *Client) HostsControllerGetOneHost(ctx context.Context, params HostsControllerGetOneHostParams, options ...RequestOption) (*GetOneHostResponseDto, error) {
	res, err := c.sendHostsControllerGetOneHost(ctx, params, options...)
	return res, err
}

func (c *Client) sendHostsControllerGetOneHost(ctx context.Context, params HostsControllerGetOneHostParams, requestOptions ...RequestOption) (res *GetOneHostResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hosts/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerGetOneHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerGetOneHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerReorderHosts invokes HostsController_reorderHosts operation.
//
// Reorder hosts.
//
// POST /api/hosts/actions/reorder
func (c *Client) HostsControllerReorderHosts(ctx context.Context, request *ReorderHostRequestDto, options ...RequestOption) (*ReorderHostResponseDto, error) {
	res, err := c.sendHostsControllerReorderHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsControllerReorderHosts(ctx context.Context, request *ReorderHostRequestDto, requestOptions ...RequestOption) (res *ReorderHostResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsControllerReorderHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerReorderHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerReorderHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerUpdateHost invokes HostsController_updateHost operation.
//
// Update a host.
//
// PATCH /api/hosts
func (c *Client) HostsControllerUpdateHost(ctx context.Context, request *UpdateHostRequestDto, options ...RequestOption) (*UpdateHostResponseDto, error) {
	res, err := c.sendHostsControllerUpdateHost(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsControllerUpdateHost(ctx context.Context, request *UpdateHostRequestDto, requestOptions ...RequestOption) (res *UpdateHostResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsControllerUpdateHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerUpdateHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerUpdateHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesControllerCreateUserHwidDevice invokes HwidUserDevicesController_createUserHwidDevice operation.
//
// Create a user HWID device.
//
// POST /api/hwid/devices
func (c *Client) HwidUserDevicesControllerCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequestDto, options ...RequestOption) (*CreateUserHwidDeviceResponseDto, error) {
	res, err := c.sendHwidUserDevicesControllerCreateUserHwidDevice(ctx, request, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesControllerCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequestDto, requestOptions ...RequestOption) (res *CreateUserHwidDeviceResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHwidUserDevicesControllerCreateUserHwidDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HwidUserDevicesControllerCreateUserHwidDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHwidUserDevicesControllerCreateUserHwidDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesControllerDeleteUserHwidDevice invokes HwidUserDevicesController_deleteUserHwidDevice operation.
//
// Delete a user HWID device.
//
// POST /api/hwid/devices/delete
func (c *Client) HwidUserDevicesControllerDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequestDto, options ...RequestOption) (*DeleteUserHwidDeviceResponseDto, error) {
	res, err := c.sendHwidUserDevicesControllerDeleteUserHwidDevice(ctx, request, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesControllerDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequestDto, requestOptions ...RequestOption) (res *DeleteUserHwidDeviceResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHwidUserDevicesControllerDeleteUserHwidDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HwidUserDevicesControllerDeleteUserHwidDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHwidUserDevicesControllerDeleteUserHwidDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesControllerGetUserHwidDevices invokes HwidUserDevicesController_getUserHwidDevices operation.
//
// Get user HWID devices.
//
// GET /api/hwid/devices/{userUuid}
func (c *Client) HwidUserDevicesControllerGetUserHwidDevices(ctx context.Context, params HwidUserDevicesControllerGetUserHwidDevicesParams, options ...RequestOption) (*GetUserHwidDevicesResponseDto, error) {
	res, err := c.sendHwidUserDevicesControllerGetUserHwidDevices(ctx, params, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesControllerGetUserHwidDevices(ctx context.Context, params HwidUserDevicesControllerGetUserHwidDevicesParams, requestOptions ...RequestOption) (res *GetUserHwidDevicesResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hwid/devices/"
	{
		// Encode "userUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HwidUserDevicesControllerGetUserHwidDevicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHwidUserDevicesControllerGetUserHwidDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InboundsBulkActionsControllerAddInboundToNodes invokes InboundsBulkActionsController_addInboundToNodes operation.
//
// Add inbound to nodes.
//
// POST /api/inbounds/bulk/add-to-nodes
func (c *Client) InboundsBulkActionsControllerAddInboundToNodes(ctx context.Context, request *AddInboundToNodesRequestDto, options ...RequestOption) (*AddInboundToNodesResponseDto, error) {
	res, err := c.sendInboundsBulkActionsControllerAddInboundToNodes(ctx, request, options...)
	return res, err
}

func (c *Client) sendInboundsBulkActionsControllerAddInboundToNodes(ctx context.Context, request *AddInboundToNodesRequestDto, requestOptions ...RequestOption) (res *AddInboundToNodesResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/inbounds/bulk/add-to-nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInboundsBulkActionsControllerAddInboundToNodesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InboundsBulkActionsControllerAddInboundToNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInboundsBulkActionsControllerAddInboundToNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InboundsBulkActionsControllerAddInboundToUsers invokes InboundsBulkActionsController_addInboundToUsers operation.
//
// Add inbound to users.
//
// POST /api/inbounds/bulk/add-to-users
func (c *Client) InboundsBulkActionsControllerAddInboundToUsers(ctx context.Context, request *AddInboundToUsersRequestDto, options ...RequestOption) (*AddInboundToUsersResponseDto, error) {
	res, err := c.sendInboundsBulkActionsControllerAddInboundToUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendInboundsBulkActionsControllerAddInboundToUsers(ctx context.Context, request *AddInboundToUsersRequestDto, requestOptions ...RequestOption) (res *AddInboundToUsersResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/inbounds/bulk/add-to-users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInboundsBulkActionsControllerAddInboundToUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InboundsBulkActionsControllerAddInboundToUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInboundsBulkActionsControllerAddInboundToUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InboundsBulkActionsControllerRemoveInboundFromNodes invokes InboundsBulkActionsController_removeInboundFromNodes operation.
//
// Remove inbound from nodes.
//
// POST /api/inbounds/bulk/remove-from-nodes
func (c *Client) InboundsBulkActionsControllerRemoveInboundFromNodes(ctx context.Context, request *RemoveInboundFromNodesRequestDto, options ...RequestOption) (*RemoveInboundFromNodesResponseDto, error) {
	res, err := c.sendInboundsBulkActionsControllerRemoveInboundFromNodes(ctx, request, options...)
	return res, err
}

func (c *Client) sendInboundsBulkActionsControllerRemoveInboundFromNodes(ctx context.Context, request *RemoveInboundFromNodesRequestDto, requestOptions ...RequestOption) (res *RemoveInboundFromNodesResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/inbounds/bulk/remove-from-nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInboundsBulkActionsControllerRemoveInboundFromNodesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InboundsBulkActionsControllerRemoveInboundFromNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInboundsBulkActionsControllerRemoveInboundFromNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InboundsBulkActionsControllerRemoveInboundFromUsers invokes InboundsBulkActionsController_removeInboundFromUsers operation.
//
// Remove inbound from users.
//
// POST /api/inbounds/bulk/remove-from-users
func (c *Client) InboundsBulkActionsControllerRemoveInboundFromUsers(ctx context.Context, request *RemoveInboundFromUsersRequestDto, options ...RequestOption) (*RemoveInboundFromUsersResponseDto, error) {
	res, err := c.sendInboundsBulkActionsControllerRemoveInboundFromUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendInboundsBulkActionsControllerRemoveInboundFromUsers(ctx context.Context, request *RemoveInboundFromUsersRequestDto, requestOptions ...RequestOption) (res *RemoveInboundFromUsersResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/inbounds/bulk/remove-from-users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInboundsBulkActionsControllerRemoveInboundFromUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InboundsBulkActionsControllerRemoveInboundFromUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInboundsBulkActionsControllerRemoveInboundFromUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InboundsControllerGetFullInbounds invokes InboundsController_getFullInbounds operation.
//
// Get inbounds with full details.
//
// GET /api/inbounds/full
func (c *Client) InboundsControllerGetFullInbounds(ctx context.Context, options ...RequestOption) (*GetFullInboundsResponseDto, error) {
	res, err := c.sendInboundsControllerGetFullInbounds(ctx, options...)
	return res, err
}

func (c *Client) sendInboundsControllerGetFullInbounds(ctx context.Context, requestOptions ...RequestOption) (res *GetFullInboundsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/inbounds/full"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InboundsControllerGetFullInboundsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInboundsControllerGetFullInboundsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InboundsControllerGetInbounds invokes InboundsController_getInbounds operation.
//
// Get inbounds.
//
// GET /api/inbounds
func (c *Client) InboundsControllerGetInbounds(ctx context.Context, options ...RequestOption) (*GetInboundsResponseDto, error) {
	res, err := c.sendInboundsControllerGetInbounds(ctx, options...)
	return res, err
}

func (c *Client) sendInboundsControllerGetInbounds(ctx context.Context, requestOptions ...RequestOption) (res *GetInboundsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/inbounds"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InboundsControllerGetInboundsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInboundsControllerGetInboundsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KeygenControllerGenerateKey invokes KeygenController_generateKey operation.
//
// Get SSL_CERT for Aura Node.
//
// GET /api/keygen
func (c *Client) KeygenControllerGenerateKey(ctx context.Context, options ...RequestOption) (*GetPubKeyResponseDto, error) {
	res, err := c.sendKeygenControllerGenerateKey(ctx, options...)
	return res, err
}

func (c *Client) sendKeygenControllerGenerateKey(ctx context.Context, requestOptions ...RequestOption) (res *GetPubKeyResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/keygen"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, KeygenControllerGenerateKeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeKeygenControllerGenerateKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerCreateNode invokes NodesController_createNode operation.
//
// Create a new node.
//
// POST /api/nodes
func (c *Client) NodesControllerCreateNode(ctx context.Context, request *CreateNodeRequestDto, options ...RequestOption) (*CreateNodeResponseDto, error) {
	res, err := c.sendNodesControllerCreateNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesControllerCreateNode(ctx context.Context, request *CreateNodeRequestDto, requestOptions ...RequestOption) (res *CreateNodeResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesControllerCreateNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerCreateNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerCreateNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerDeleteNode invokes NodesController_deleteNode operation.
//
// Delete a node.
//
// DELETE /api/nodes/{uuid}
func (c *Client) NodesControllerDeleteNode(ctx context.Context, params NodesControllerDeleteNodeParams, options ...RequestOption) (*DeleteNodeResponseDto, error) {
	res, err := c.sendNodesControllerDeleteNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerDeleteNode(ctx context.Context, params NodesControllerDeleteNodeParams, requestOptions ...RequestOption) (res *DeleteNodeResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerDeleteNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerDeleteNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerDisableNode invokes NodesController_disableNode operation.
//
// Disable a node.
//
// POST /api/nodes/{uuid}/actions/disable
func (c *Client) NodesControllerDisableNode(ctx context.Context, params NodesControllerDisableNodeParams, options ...RequestOption) (*DisableNodeResponseDto, error) {
	res, err := c.sendNodesControllerDisableNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerDisableNode(ctx context.Context, params NodesControllerDisableNodeParams, requestOptions ...RequestOption) (res *DisableNodeResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerDisableNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerDisableNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerEnableNode invokes NodesController_enableNode operation.
//
// Enable a node.
//
// POST /api/nodes/{uuid}/actions/enable
func (c *Client) NodesControllerEnableNode(ctx context.Context, params NodesControllerEnableNodeParams, options ...RequestOption) (*EnableNodeResponseDto, error) {
	res, err := c.sendNodesControllerEnableNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerEnableNode(ctx context.Context, params NodesControllerEnableNodeParams, requestOptions ...RequestOption) (res *EnableNodeResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerEnableNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerEnableNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerGetAllNodes invokes NodesController_getAllNodes operation.
//
// Get all nodes.
//
// GET /api/nodes
func (c *Client) NodesControllerGetAllNodes(ctx context.Context, options ...RequestOption) (*GetAllNodesResponseDto, error) {
	res, err := c.sendNodesControllerGetAllNodes(ctx, options...)
	return res, err
}

func (c *Client) sendNodesControllerGetAllNodes(ctx context.Context, requestOptions ...RequestOption) (res *GetAllNodesResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerGetAllNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerGetAllNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerGetOneNode invokes NodesController_getOneNode operation.
//
// Get node by UUID.
//
// GET /api/nodes/{uuid}
func (c *Client) NodesControllerGetOneNode(ctx context.Context, params NodesControllerGetOneNodeParams, options ...RequestOption) (*GetOneNodeResponseDto, error) {
	res, err := c.sendNodesControllerGetOneNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerGetOneNode(ctx context.Context, params NodesControllerGetOneNodeParams, requestOptions ...RequestOption) (res *GetOneNodeResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerGetOneNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerGetOneNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerReorderNodes invokes NodesController_reorderNodes operation.
//
// Reorder nodes.
//
// POST /api/nodes/actions/reorder
func (c *Client) NodesControllerReorderNodes(ctx context.Context, request *ReorderNodeRequestDto, options ...RequestOption) (*ReorderNodeResponseDto, error) {
	res, err := c.sendNodesControllerReorderNodes(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesControllerReorderNodes(ctx context.Context, request *ReorderNodeRequestDto, requestOptions ...RequestOption) (res *ReorderNodeResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesControllerReorderNodesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerReorderNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerReorderNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerRestartAllNodes invokes NodesController_restartAllNodes operation.
//
// Restart all nodes.
//
// POST /api/nodes/actions/restart-all
func (c *Client) NodesControllerRestartAllNodes(ctx context.Context, options ...RequestOption) (*RestartAllNodesResponseDto, error) {
	res, err := c.sendNodesControllerRestartAllNodes(ctx, options...)
	return res, err
}

func (c *Client) sendNodesControllerRestartAllNodes(ctx context.Context, requestOptions ...RequestOption) (res *RestartAllNodesResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/actions/restart-all"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerRestartAllNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerRestartAllNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerRestartNode invokes NodesController_restartNode operation.
//
// Restart node.
//
// POST /api/nodes/{uuid}/actions/restart
func (c *Client) NodesControllerRestartNode(ctx context.Context, params NodesControllerRestartNodeParams, options ...RequestOption) (*RestartNodeResponseDto, error) {
	res, err := c.sendNodesControllerRestartNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerRestartNode(ctx context.Context, params NodesControllerRestartNodeParams, requestOptions ...RequestOption) (res *RestartNodeResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/restart"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerRestartNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerRestartNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerUpdateNode invokes NodesController_updateNode operation.
//
// Update node.
//
// PATCH /api/nodes
func (c *Client) NodesControllerUpdateNode(ctx context.Context, request *UpdateNodeRequestDto, options ...RequestOption) (*UpdateNodeResponseDto, error) {
	res, err := c.sendNodesControllerUpdateNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesControllerUpdateNode(ctx context.Context, request *UpdateNodeRequestDto, requestOptions ...RequestOption) (res *UpdateNodeResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesControllerUpdateNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerUpdateNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerUpdateNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUsageHistoryControllerGetNodesUsageByRange invokes NodesUsageHistoryController_getNodesUsageByRange operation.
//
// Get nodes usage by range.
//
// GET /api/nodes/usage/range
func (c *Client) NodesUsageHistoryControllerGetNodesUsageByRange(ctx context.Context, params NodesUsageHistoryControllerGetNodesUsageByRangeParams, options ...RequestOption) (*GetNodesUsageByRangeResponseDto, error) {
	res, err := c.sendNodesUsageHistoryControllerGetNodesUsageByRange(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesUsageHistoryControllerGetNodesUsageByRange(ctx context.Context, params NodesUsageHistoryControllerGetNodesUsageByRangeParams, requestOptions ...RequestOption) (res *GetNodesUsageByRangeResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/usage/range"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesUsageHistoryControllerGetNodesUsageByRangeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesUsageHistoryControllerGetNodesUsageByRangeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUserUsageHistoryControllerGetNodeUserUsage invokes NodesUserUsageHistoryController_getNodeUserUsage operation.
//
// Get node user usage by range and Node UUID.
//
// GET /api/nodes/usage/{uuid}/users/range
func (c *Client) NodesUserUsageHistoryControllerGetNodeUserUsage(ctx context.Context, params NodesUserUsageHistoryControllerGetNodeUserUsageParams, options ...RequestOption) (*GetNodeUserUsageByRangeResponseDto, error) {
	res, err := c.sendNodesUserUsageHistoryControllerGetNodeUserUsage(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesUserUsageHistoryControllerGetNodeUserUsage(ctx context.Context, params NodesUserUsageHistoryControllerGetNodeUserUsageParams, requestOptions ...RequestOption) (res *GetNodeUserUsageByRangeResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/usage/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/range"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesUserUsageHistoryControllerGetNodeUserUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesUserUsageHistoryControllerGetNodeUserUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUserUsageHistoryControllerGetNodesRealtimeUsage invokes NodesUserUsageHistoryController_getNodesRealtimeUsage operation.
//
// Get nodes realtime usage.
//
// GET /api/nodes/usage/realtime
func (c *Client) NodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx context.Context, options ...RequestOption) (*GetNodesRealtimeUsageResponseDto, error) {
	res, err := c.sendNodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx, options...)
	return res, err
}

func (c *Client) sendNodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx context.Context, requestOptions ...RequestOption) (res *GetNodesRealtimeUsageResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/usage/realtime"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesUserUsageHistoryControllerGetNodesRealtimeUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesUserUsageHistoryControllerGetNodesRealtimeUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscription invokes SubscriptionController_getSubscription operation.
//
// GET /api/sub/{shortUuid}
func (c *Client) SubscriptionControllerGetSubscription(ctx context.Context, params SubscriptionControllerGetSubscriptionParams, options ...RequestOption) error {
	_, err := c.sendSubscriptionControllerGetSubscription(ctx, params, options...)
	return err
}

func (c *Client) sendSubscriptionControllerGetSubscription(ctx context.Context, params SubscriptionControllerGetSubscriptionParams, requestOptions ...RequestOption) (res *SubscriptionControllerGetSubscriptionOK, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscriptionByClientType invokes SubscriptionController_getSubscriptionByClientType operation.
//
// GET /api/sub/{shortUuid}/{clientType}
func (c *Client) SubscriptionControllerGetSubscriptionByClientType(ctx context.Context, params SubscriptionControllerGetSubscriptionByClientTypeParams, options ...RequestOption) error {
	_, err := c.sendSubscriptionControllerGetSubscriptionByClientType(ctx, params, options...)
	return err
}

func (c *Client) sendSubscriptionControllerGetSubscriptionByClientType(ctx context.Context, params SubscriptionControllerGetSubscriptionByClientTypeParams, requestOptions ...RequestOption) (res *SubscriptionControllerGetSubscriptionByClientTypeOK, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "clientType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clientType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.ClientType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionByClientTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscriptionInfoByShortUuid invokes SubscriptionController_getSubscriptionInfoByShortUuid operation.
//
// Get Subscription Info by Short UUID.
//
// GET /api/sub/{shortUuid}/info
func (c *Client) SubscriptionControllerGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionControllerGetSubscriptionInfoByShortUuidParams, options ...RequestOption) (*GetSubscriptionInfoResponseDto, error) {
	res, err := c.sendSubscriptionControllerGetSubscriptionInfoByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionControllerGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionControllerGetSubscriptionInfoByShortUuidParams, requestOptions ...RequestOption) (res *GetSubscriptionInfoResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/info"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionInfoByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscriptionWithType invokes SubscriptionController_getSubscriptionWithType operation.
//
// GET /api/sub/outline/{shortUuid}/{type}/{encodedTag}
func (c *Client) SubscriptionControllerGetSubscriptionWithType(ctx context.Context, params SubscriptionControllerGetSubscriptionWithTypeParams, options ...RequestOption) error {
	_, err := c.sendSubscriptionControllerGetSubscriptionWithType(ctx, params, options...)
	return err
}

func (c *Client) sendSubscriptionControllerGetSubscriptionWithType(ctx context.Context, params SubscriptionControllerGetSubscriptionWithTypeParams, requestOptions ...RequestOption) (res *SubscriptionControllerGetSubscriptionWithTypeOK, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [6]string
	pathParts[0] = "/api/sub/outline/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Type))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "encodedTag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encodedTag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncodedTag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionWithTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionSettingsControllerGetSettings invokes SubscriptionSettingsController_getSettings operation.
//
// Get subscription settings.
//
// GET /api/subscription-settings
func (c *Client) SubscriptionSettingsControllerGetSettings(ctx context.Context, options ...RequestOption) (*GetSubscriptionSettingsResponseDto, error) {
	res, err := c.sendSubscriptionSettingsControllerGetSettings(ctx, options...)
	return res, err
}

func (c *Client) sendSubscriptionSettingsControllerGetSettings(ctx context.Context, requestOptions ...RequestOption) (res *GetSubscriptionSettingsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-settings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionSettingsControllerGetSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionSettingsControllerGetSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionSettingsControllerUpdateSettings invokes SubscriptionSettingsController_updateSettings operation.
//
// Update subscription settings.
//
// PATCH /api/subscription-settings
func (c *Client) SubscriptionSettingsControllerUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequestDto, options ...RequestOption) (*UpdateSubscriptionSettingsResponseDto, error) {
	res, err := c.sendSubscriptionSettingsControllerUpdateSettings(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionSettingsControllerUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequestDto, requestOptions ...RequestOption) (res *UpdateSubscriptionSettingsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-settings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionSettingsControllerUpdateSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionSettingsControllerUpdateSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionSettingsControllerUpdateSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateControllerGetTemplate invokes SubscriptionTemplateController_getTemplate operation.
//
// Get subscription template.
//
// GET /api/subscription-templates/{templateType}
func (c *Client) SubscriptionTemplateControllerGetTemplate(ctx context.Context, params SubscriptionTemplateControllerGetTemplateParams, options ...RequestOption) (*GetTemplateResponseDto, error) {
	res, err := c.sendSubscriptionTemplateControllerGetTemplate(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateControllerGetTemplate(ctx context.Context, params SubscriptionTemplateControllerGetTemplateParams, requestOptions ...RequestOption) (res *GetTemplateResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscription-templates/"
	{
		// Encode "templateType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "templateType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.TemplateType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionTemplateControllerGetTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionTemplateControllerGetTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateControllerUpdateTemplate invokes SubscriptionTemplateController_updateTemplate operation.
//
// Update subscription template.
//
// PUT /api/subscription-templates
func (c *Client) SubscriptionTemplateControllerUpdateTemplate(ctx context.Context, request *UpdateTemplateRequestDto, options ...RequestOption) (*UpdateTemplateResponseDto, error) {
	res, err := c.sendSubscriptionTemplateControllerUpdateTemplate(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateControllerUpdateTemplate(ctx context.Context, request *UpdateTemplateRequestDto, requestOptions ...RequestOption) (res *UpdateTemplateResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-templates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionTemplateControllerUpdateTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionTemplateControllerUpdateTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionTemplateControllerUpdateTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsControllerGetAllSubscriptions invokes SubscriptionsController_getAllSubscriptions operation.
//
// Get all subscriptions.
//
// GET /api/subscriptions
func (c *Client) SubscriptionsControllerGetAllSubscriptions(ctx context.Context, params SubscriptionsControllerGetAllSubscriptionsParams, options ...RequestOption) (*GetAllSubscriptionsResponseDto, error) {
	res, err := c.sendSubscriptionsControllerGetAllSubscriptions(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsControllerGetAllSubscriptions(ctx context.Context, params SubscriptionsControllerGetAllSubscriptionsParams, requestOptions ...RequestOption) (res *GetAllSubscriptionsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionsControllerGetAllSubscriptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionsControllerGetAllSubscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsControllerGetSubscriptionByUsername invokes SubscriptionsController_getSubscriptionByUsername operation.
//
// Get subscription by username.
//
// GET /api/subscriptions/by-username/{username}
func (c *Client) SubscriptionsControllerGetSubscriptionByUsername(ctx context.Context, params SubscriptionsControllerGetSubscriptionByUsernameParams, options ...RequestOption) (SubscriptionsControllerGetSubscriptionByUsernameRes, error) {
	res, err := c.sendSubscriptionsControllerGetSubscriptionByUsername(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsControllerGetSubscriptionByUsername(ctx context.Context, params SubscriptionsControllerGetSubscriptionByUsernameParams, requestOptions ...RequestOption) (res SubscriptionsControllerGetSubscriptionByUsernameRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscriptions/by-username/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionsControllerGetSubscriptionByUsernameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionsControllerGetSubscriptionByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetBandwidthStats invokes SystemController_getBandwidthStats operation.
//
// Get Bandwidth Stats.
//
// GET /api/system/stats/bandwidth
func (c *Client) SystemControllerGetBandwidthStats(ctx context.Context, options ...RequestOption) (*GetBandwidthStatsResponseDto, error) {
	res, err := c.sendSystemControllerGetBandwidthStats(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetBandwidthStats(ctx context.Context, requestOptions ...RequestOption) (res *GetBandwidthStatsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats/bandwidth"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetBandwidthStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetBandwidthStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetNodesStatistics invokes SystemController_getNodesStatistics operation.
//
// Get Nodes Statistics.
//
// GET /api/system/stats/nodes
func (c *Client) SystemControllerGetNodesStatistics(ctx context.Context, options ...RequestOption) (*GetNodesStatisticsResponseDto, error) {
	res, err := c.sendSystemControllerGetNodesStatistics(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetNodesStatistics(ctx context.Context, requestOptions ...RequestOption) (res *GetNodesStatisticsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetNodesStatisticsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetNodesStatisticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetStats invokes SystemController_getStats operation.
//
// Get Stats.
//
// GET /api/system/stats
func (c *Client) SystemControllerGetStats(ctx context.Context, options ...RequestOption) (*GetStatsResponseDto, error) {
	res, err := c.sendSystemControllerGetStats(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetStats(ctx context.Context, requestOptions ...RequestOption) (res *GetStatsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkAllResetUserTraffic invokes UsersBulkActionsController_bulkAllResetUserTraffic operation.
//
// Bulk reset all users traffic.
//
// POST /api/users/bulk/all/reset-traffic
func (c *Client) UsersBulkActionsControllerBulkAllResetUserTraffic(ctx context.Context, options ...RequestOption) (*BulkAllResetTrafficUsersResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkAllResetUserTraffic(ctx, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkAllResetUserTraffic(ctx context.Context, requestOptions ...RequestOption) (res *BulkAllResetTrafficUsersResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/all/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkAllResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkAllResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkDeleteUsers invokes UsersBulkActionsController_bulkDeleteUsers operation.
//
// Bulk delete users by UUIDs.
//
// POST /api/users/bulk/delete
func (c *Client) UsersBulkActionsControllerBulkDeleteUsers(ctx context.Context, request *BulkDeleteUsersRequestDto, options ...RequestOption) (*BulkDeleteUsersResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkDeleteUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkDeleteUsers(ctx context.Context, request *BulkDeleteUsersRequestDto, requestOptions ...RequestOption) (res *BulkDeleteUsersResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkDeleteUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkDeleteUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkDeleteUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkDeleteUsersByStatus invokes UsersBulkActionsController_bulkDeleteUsersByStatus operation.
//
// Bulk delete users by status.
//
// POST /api/users/bulk/delete-by-status
func (c *Client) UsersBulkActionsControllerBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequestDto, options ...RequestOption) (*BulkDeleteUsersByStatusResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkDeleteUsersByStatus(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequestDto, requestOptions ...RequestOption) (res *BulkDeleteUsersByStatusResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/delete-by-status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkDeleteUsersByStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkDeleteUsersByStatusOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkDeleteUsersByStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkResetUserTraffic invokes UsersBulkActionsController_bulkResetUserTraffic operation.
//
// Bulk reset traffic users by UUIDs.
//
// POST /api/users/bulk/reset-traffic
func (c *Client) UsersBulkActionsControllerBulkResetUserTraffic(ctx context.Context, request *BulkResetTrafficUsersRequestDto, options ...RequestOption) (*BulkResetTrafficUsersResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkResetUserTraffic(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkResetUserTraffic(ctx context.Context, request *BulkResetTrafficUsersRequestDto, requestOptions ...RequestOption) (res *BulkResetTrafficUsersResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkResetUserTrafficRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkRevokeUsersSubscription invokes UsersBulkActionsController_bulkRevokeUsersSubscription operation.
//
// Revoke users subscription by User UUIDs.
//
// POST /api/users/bulk/revoke-subscription
func (c *Client) UsersBulkActionsControllerBulkRevokeUsersSubscription(ctx context.Context, request *BulkRevokeUsersSubscriptionRequestDto, options ...RequestOption) (*BulkRevokeUsersSubscriptionResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkRevokeUsersSubscription(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkRevokeUsersSubscription(ctx context.Context, request *BulkRevokeUsersSubscriptionRequestDto, requestOptions ...RequestOption) (res *BulkRevokeUsersSubscriptionResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/revoke-subscription"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkRevokeUsersSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkRevokeUsersSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkRevokeUsersSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkUpdateAllUsers invokes UsersBulkActionsController_bulkUpdateAllUsers operation.
//
// Bulk update all users.
//
// POST /api/users/bulk/all/update
func (c *Client) UsersBulkActionsControllerBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequestDto, options ...RequestOption) (*BulkAllUpdateUsersResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkUpdateAllUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequestDto, requestOptions ...RequestOption) (res *BulkAllUpdateUsersResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/all/update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkUpdateAllUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkUpdateAllUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkUpdateAllUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkUpdateUsers invokes UsersBulkActionsController_bulkUpdateUsers operation.
//
// Bulk update users by UUIDs.
//
// POST /api/users/bulk/update
func (c *Client) UsersBulkActionsControllerBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequestDto, options ...RequestOption) (*BulkUpdateUsersResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkUpdateUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequestDto, requestOptions ...RequestOption) (res *BulkUpdateUsersResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkUpdateUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkUpdateUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkUpdateUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkUpdateUsersInbounds invokes UsersBulkActionsController_bulkUpdateUsersInbounds operation.
//
// Bulk update users inbounds by UUIDs.
//
// POST /api/users/bulk/update-inbounds
func (c *Client) UsersBulkActionsControllerBulkUpdateUsersInbounds(ctx context.Context, request *BulkUpdateUsersInboundsRequestDto, options ...RequestOption) (*BulkUpdateUsersInboundsResponseDto, error) {
	res, err := c.sendUsersBulkActionsControllerBulkUpdateUsersInbounds(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkUpdateUsersInbounds(ctx context.Context, request *BulkUpdateUsersInboundsRequestDto, requestOptions ...RequestOption) (res *BulkUpdateUsersInboundsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/update-inbounds"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkUpdateUsersInboundsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkUpdateUsersInboundsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkUpdateUsersInboundsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerActivateAllInbounds invokes UsersController_activateAllInbounds operation.
//
// Activate all inbounds.
//
// POST /api/users/{uuid}/actions/activate-all-inbounds
func (c *Client) UsersControllerActivateAllInbounds(ctx context.Context, params UsersControllerActivateAllInboundsParams, options ...RequestOption) (UsersControllerActivateAllInboundsRes, error) {
	res, err := c.sendUsersControllerActivateAllInbounds(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerActivateAllInbounds(ctx context.Context, params UsersControllerActivateAllInboundsParams, requestOptions ...RequestOption) (res UsersControllerActivateAllInboundsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/activate-all-inbounds"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerActivateAllInboundsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerActivateAllInboundsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerCreateUser invokes UsersController_createUser operation.
//
// Create a new user.
//
// POST /api/users
func (c *Client) UsersControllerCreateUser(ctx context.Context, request *CreateUserRequestDto, options ...RequestOption) (*UserResponseDto, error) {
	res, err := c.sendUsersControllerCreateUser(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersControllerCreateUser(ctx context.Context, request *CreateUserRequestDto, requestOptions ...RequestOption) (res *UserResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersControllerCreateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerCreateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerCreateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerDeleteUser invokes UsersController_deleteUser operation.
//
// Delete user.
//
// DELETE /api/users/{uuid}
func (c *Client) UsersControllerDeleteUser(ctx context.Context, params UsersControllerDeleteUserParams, options ...RequestOption) (UsersControllerDeleteUserRes, error) {
	res, err := c.sendUsersControllerDeleteUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerDeleteUser(ctx context.Context, params UsersControllerDeleteUserParams, requestOptions ...RequestOption) (res UsersControllerDeleteUserRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerDeleteUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerDeleteUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerDisableUser invokes UsersController_disableUser operation.
//
// Disable user.
//
// POST /api/users/{uuid}/actions/disable
func (c *Client) UsersControllerDisableUser(ctx context.Context, params UsersControllerDisableUserParams, options ...RequestOption) (UsersControllerDisableUserRes, error) {
	res, err := c.sendUsersControllerDisableUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerDisableUser(ctx context.Context, params UsersControllerDisableUserParams, requestOptions ...RequestOption) (res UsersControllerDisableUserRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerDisableUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerDisableUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerEnableUser invokes UsersController_enableUser operation.
//
// Enable user.
//
// POST /api/users/{uuid}/actions/enable
func (c *Client) UsersControllerEnableUser(ctx context.Context, params UsersControllerEnableUserParams, options ...RequestOption) (UsersControllerEnableUserRes, error) {
	res, err := c.sendUsersControllerEnableUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerEnableUser(ctx context.Context, params UsersControllerEnableUserParams, requestOptions ...RequestOption) (res UsersControllerEnableUserRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerEnableUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerEnableUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetAllTags invokes UsersController_getAllTags operation.
//
// Get all existing user tags.
//
// GET /api/users/tags
func (c *Client) UsersControllerGetAllTags(ctx context.Context, options ...RequestOption) (*GetAllTagsResponseDto, error) {
	res, err := c.sendUsersControllerGetAllTags(ctx, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetAllTags(ctx context.Context, requestOptions ...RequestOption) (res *GetAllTagsResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetAllTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetAllTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetAllUsers invokes UsersController_getAllUsers operation.
//
// Get all users.
//
// GET /api/users
func (c *Client) UsersControllerGetAllUsers(ctx context.Context, params UsersControllerGetAllUsersParams, options ...RequestOption) (*GetAllUsersResponseDto, error) {
	res, err := c.sendUsersControllerGetAllUsers(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetAllUsers(ctx context.Context, params UsersControllerGetAllUsersParams, requestOptions ...RequestOption) (res *GetAllUsersResponseDto, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetAllUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetAllUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByShortUuid invokes UsersController_getUserByShortUuid operation.
//
// Get user by Short UUID.
//
// GET /api/users/by-short-uuid/{shortUuid}
func (c *Client) UsersControllerGetUserByShortUuid(ctx context.Context, params UsersControllerGetUserByShortUuidParams, options ...RequestOption) (UsersControllerGetUserByShortUuidRes, error) {
	res, err := c.sendUsersControllerGetUserByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByShortUuid(ctx context.Context, params UsersControllerGetUserByShortUuidParams, requestOptions ...RequestOption) (res UsersControllerGetUserByShortUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-short-uuid/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByShortUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserBySubscriptionUuid invokes UsersController_getUserBySubscriptionUuid operation.
//
// Get user by subscription UUID.
//
// GET /api/users/by-subscription-uuid/{subscriptionUuid}
func (c *Client) UsersControllerGetUserBySubscriptionUuid(ctx context.Context, params UsersControllerGetUserBySubscriptionUuidParams, options ...RequestOption) (UsersControllerGetUserBySubscriptionUuidRes, error) {
	res, err := c.sendUsersControllerGetUserBySubscriptionUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserBySubscriptionUuid(ctx context.Context, params UsersControllerGetUserBySubscriptionUuidParams, requestOptions ...RequestOption) (res UsersControllerGetUserBySubscriptionUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-subscription-uuid/"
	{
		// Encode "subscriptionUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "subscriptionUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SubscriptionUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserBySubscriptionUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserBySubscriptionUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByTelegramId invokes UsersController_getUserByTelegramId operation.
//
// Get users by telegram ID.
//
// GET /api/users/by-telegram-id/{telegramId}
func (c *Client) UsersControllerGetUserByTelegramId(ctx context.Context, params UsersControllerGetUserByTelegramIdParams, options ...RequestOption) (UsersControllerGetUserByTelegramIdRes, error) {
	res, err := c.sendUsersControllerGetUserByTelegramId(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByTelegramId(ctx context.Context, params UsersControllerGetUserByTelegramIdParams, requestOptions ...RequestOption) (res UsersControllerGetUserByTelegramIdRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-telegram-id/"
	{
		// Encode "telegramId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "telegramId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TelegramId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByTelegramIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByTelegramIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByUsername invokes UsersController_getUserByUsername operation.
//
// Get user by username.
//
// GET /api/users/by-username/{username}
func (c *Client) UsersControllerGetUserByUsername(ctx context.Context, params UsersControllerGetUserByUsernameParams, options ...RequestOption) (UsersControllerGetUserByUsernameRes, error) {
	res, err := c.sendUsersControllerGetUserByUsername(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByUsername(ctx context.Context, params UsersControllerGetUserByUsernameParams, requestOptions ...RequestOption) (res UsersControllerGetUserByUsernameRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-username/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByUsernameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByUuid invokes UsersController_getUserByUuid operation.
//
// Get user by UUID.
//
// GET /api/users/{uuid}
func (c *Client) UsersControllerGetUserByUuid(ctx context.Context, params UsersControllerGetUserByUuidParams, options ...RequestOption) (UsersControllerGetUserByUuidRes, error) {
	res, err := c.sendUsersControllerGetUserByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByUuid(ctx context.Context, params UsersControllerGetUserByUuidParams, requestOptions ...RequestOption) (res UsersControllerGetUserByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUsersByEmail invokes UsersController_getUsersByEmail operation.
//
// Get users by email.
//
// GET /api/users/by-email/{email}
func (c *Client) UsersControllerGetUsersByEmail(ctx context.Context, params UsersControllerGetUsersByEmailParams, options ...RequestOption) (UsersControllerGetUsersByEmailRes, error) {
	res, err := c.sendUsersControllerGetUsersByEmail(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUsersByEmail(ctx context.Context, params UsersControllerGetUsersByEmailParams, requestOptions ...RequestOption) (res UsersControllerGetUsersByEmailRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-email/"
	{
		// Encode "email" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "email",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Email))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUsersByEmailOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUsersByEmailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUsersByTag invokes UsersController_getUsersByTag operation.
//
// Get users by tag.
//
// GET /api/users/by-tag/{tag}
func (c *Client) UsersControllerGetUsersByTag(ctx context.Context, params UsersControllerGetUsersByTagParams, options ...RequestOption) (UsersControllerGetUsersByTagRes, error) {
	res, err := c.sendUsersControllerGetUsersByTag(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUsersByTag(ctx context.Context, params UsersControllerGetUsersByTagParams, requestOptions ...RequestOption) (res UsersControllerGetUsersByTagRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-tag/"
	{
		// Encode "tag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Tag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUsersByTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUsersByTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerResetUserTraffic invokes UsersController_resetUserTraffic operation.
//
// Reset user traffic.
//
// POST /api/users/{uuid}/actions/reset-traffic
func (c *Client) UsersControllerResetUserTraffic(ctx context.Context, params UsersControllerResetUserTrafficParams, options ...RequestOption) (UsersControllerResetUserTrafficRes, error) {
	res, err := c.sendUsersControllerResetUserTraffic(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerResetUserTraffic(ctx context.Context, params UsersControllerResetUserTrafficParams, requestOptions ...RequestOption) (res UsersControllerResetUserTrafficRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerRevokeUserSubscription invokes UsersController_revokeUserSubscription operation.
//
// Revoke user subscription.
//
// POST /api/users/{uuid}/actions/revoke
func (c *Client) UsersControllerRevokeUserSubscription(ctx context.Context, params UsersControllerRevokeUserSubscriptionParams, options ...RequestOption) (UsersControllerRevokeUserSubscriptionRes, error) {
	res, err := c.sendUsersControllerRevokeUserSubscription(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerRevokeUserSubscription(ctx context.Context, params UsersControllerRevokeUserSubscriptionParams, requestOptions ...RequestOption) (res UsersControllerRevokeUserSubscriptionRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerRevokeUserSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerRevokeUserSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerUpdateUser invokes UsersController_updateUser operation.
//
// Update a user.
//
// PATCH /api/users
func (c *Client) UsersControllerUpdateUser(ctx context.Context, request *UpdateUserRequestDto, options ...RequestOption) (*UserResponseDto, error) {
	res, err := c.sendUsersControllerUpdateUser(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersControllerUpdateUser(ctx context.Context, request *UpdateUserRequestDto, requestOptions ...RequestOption) (res *UserResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersControllerUpdateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerUpdateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerUpdateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersStatsControllerGetUserUsageByRange invokes UsersStatsController_getUserUsageByRange operation.
//
// Get user usage by range.
//
// GET /api/users/stats/usage/{uuid}/range
func (c *Client) UsersStatsControllerGetUserUsageByRange(ctx context.Context, params UsersStatsControllerGetUserUsageByRangeParams, options ...RequestOption) (UsersStatsControllerGetUserUsageByRangeRes, error) {
	res, err := c.sendUsersStatsControllerGetUserUsageByRange(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersStatsControllerGetUserUsageByRange(ctx context.Context, params UsersStatsControllerGetUserUsageByRangeParams, requestOptions ...RequestOption) (res UsersStatsControllerGetUserUsageByRangeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/stats/usage/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/range"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersStatsControllerGetUserUsageByRangeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersStatsControllerGetUserUsageByRangeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// XrayConfigControllerGetConfig invokes XrayConfigController_getConfig operation.
//
// Get XRay config.
//
// GET /api/xray
func (c *Client) XrayConfigControllerGetConfig(ctx context.Context, options ...RequestOption) (XrayConfigControllerGetConfigRes, error) {
	res, err := c.sendXrayConfigControllerGetConfig(ctx, options...)
	return res, err
}

func (c *Client) sendXrayConfigControllerGetConfig(ctx context.Context, requestOptions ...RequestOption) (res XrayConfigControllerGetConfigRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/xray"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, XrayConfigControllerGetConfigOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeXrayConfigControllerGetConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// XrayConfigControllerUpdateConfig invokes XrayConfigController_updateConfig operation.
//
// Update XRay config.
//
// PUT /api/xray
func (c *Client) XrayConfigControllerUpdateConfig(ctx context.Context, request *UpdateConfigRequestDto, options ...RequestOption) (XrayConfigControllerUpdateConfigRes, error) {
	res, err := c.sendXrayConfigControllerUpdateConfig(ctx, request, options...)
	return res, err
}

func (c *Client) sendXrayConfigControllerUpdateConfig(ctx context.Context, request *UpdateConfigRequestDto, requestOptions ...RequestOption) (res XrayConfigControllerUpdateConfigRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/xray"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeXrayConfigControllerUpdateConfigRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, XrayConfigControllerUpdateConfigOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeXrayConfigControllerUpdateConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
